/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./html/js/index.js":
/*!**************************!*\
  !*** ./html/js/index.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var i18next__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! i18next */ \"./node_modules/i18next/dist/esm/i18next.js\");\n/* harmony import */ var i18next_xhr_backend__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! i18next-xhr-backend */ \"./node_modules/i18next-xhr-backend/dist/esm/i18nextXHRBackend.js\");\n/* harmony import */ var loc_i18next__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! loc-i18next */ \"./node_modules/loc-i18next/index.js\");\n/* harmony import */ var loc_i18next__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(loc_i18next__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var i18next_browser_languagedetector__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! i18next-browser-languagedetector */ \"./node_modules/i18next-browser-languagedetector/dist/esm/i18nextBrowserLanguageDetector.js\");\n/* harmony import */ var animate_css__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! animate.css */ \"./node_modules/animate.css/animate.css\");\n/* harmony import */ var _utils_telMask__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils/telMask */ \"./html/js/utils/telMask.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst url = document.location.pathname;\r\n\r\nif (url.includes('/en/')) {\r\n    // Инициализация i18next\r\n    i18next__WEBPACK_IMPORTED_MODULE_0__[\"default\"].use(i18next_xhr_backend__WEBPACK_IMPORTED_MODULE_1__[\"default\"])\r\n        .use(i18next_browser_languagedetector__WEBPACK_IMPORTED_MODULE_3__[\"default\"])\r\n        .init({\r\n            fallbackLng: 'en',\r\n            whitelist: ['en'],\r\n            preload: ['en'],\r\n            ns: 'users',\r\n            defaultNS: 'users',\r\n            fallbackNS: false,\r\n            debug: false,\r\n            backend: {\r\n                loadPath: '/i18n/{{lng}}/{{ns}}.json',\r\n            },\r\n            lng: 'en',\r\n        }, function (err, t) {\r\n            if (err) return console.error('error: ', err);\r\n            // Инициализация locI18next после инициализации i18next\r\n            const loci18n = loc_i18next__WEBPACK_IMPORTED_MODULE_2___default().init(i18next__WEBPACK_IMPORTED_MODULE_0__[\"default\"], {\r\n                selectorAttr: 'data-i18n',\r\n                optionsAttr: 'data-i18n-options',\r\n                useOptionsAttr: true\r\n            });\r\n            loci18n('body');\r\n\r\n        });\r\n}\r\n\r\nvar element = document.querySelector(\".loading-text-words:last-child\");\r\nelement.addEventListener(\"animationiteration\", function () {\r\n    const loader = document.querySelector(\".loading\");\r\n    loader.classList.add(\"loader_none\")\r\n\r\n}, false);\r\n\r\n\r\n\r\n(0,_utils_telMask__WEBPACK_IMPORTED_MODULE_5__[\"default\"])();\r\n\r\nfunction createLightboxWithProps(type, sources) {\r\n    let lightbox = new FsLightbox();\r\n    lightbox.props.type = type;\r\n    lightbox.props.sources = sources;\r\n    return lightbox;\r\n}\r\n\r\nconst lightbox = () => {\r\n    const imagesSources = {\r\n        \"azs\": {\r\n            sources: [\"../images/gallery/azs/new_azs1.png\", \"../images/gallery/azs/new_azs2.png\", \r\n            \"../images/gallery/azs/new_azs3.png\", \"../images/gallery/azs/new-design_fuel_section.jpg\",\"../images/gallery/azs/new-design_fuel.jpg\", \r\n            \"../images/gallery/azs/new-design_limits.jpg\"],\r\n        },\r\n        \"mon\": {\r\n            sources: [\"../images/gallery/monitoring/mon1.png\", \"../images/gallery/monitoring/mon2.png\", \"../images/gallery/monitoring/mon3.png\", \r\n            \"../images/gallery/monitoring/mon4.png\", \"../images/gallery/monitoring/mon5.png\", \"../images/gallery/monitoring/mon6.png\"],\r\n        }\r\n    }\r\n\r\n    const imgPills = document.getElementById(\"pills-tabContentService\");\r\n    const images = imgPills.querySelectorAll(\".services__section_block_img img\");\r\n\r\n    for (const key in imagesSources) {\r\n        if (imagesSources.hasOwnProperty(key)) {\r\n            const imgSources = imagesSources[key].sources;\r\n            // Создание экземпляра FsLightbox для каждого набора изображений\r\n            const lightbox = createLightboxWithProps(\"image\", imgSources);\r\n\r\n            imagesSources[key].lightbox = lightbox;\r\n        }\r\n    }\r\n\r\n    [...images].forEach((img) => {\r\n        img.addEventListener(\"click\", function () {\r\n            imagesSources[this.dataset.id].lightbox.open();\r\n        })\r\n\r\n    });\r\n\r\n\r\n};\r\n\r\ndocument.addEventListener(\"DOMContentLoaded\", lightbox);\r\n\r\n\r\n// export { loci18n as loci18n, i18next as i18n };\r\n\r\n\n\n//# sourceURL=webpack://gut.tech/./html/js/index.js?");

/***/ }),

/***/ "./html/js/utils/telMask.js":
/*!**********************************!*\
  !*** ./html/js/utils/telMask.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ telMask)\n/* harmony export */ });\n/* harmony import */ var intl_tel_input_build_css_intlTelInput_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! intl-tel-input/build/css/intlTelInput.css */ \"./node_modules/intl-tel-input/build/css/intlTelInput.css\");\n/* harmony import */ var intl_tel_input__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! intl-tel-input */ \"./node_modules/intl-tel-input/index.js\");\n/* harmony import */ var intl_tel_input__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(intl_tel_input__WEBPACK_IMPORTED_MODULE_1__);\n\r\n\r\n\r\nfunction telMask() {\r\n    const input = document.getElementById(\"tel\");\r\n\r\n    const iti = intl_tel_input__WEBPACK_IMPORTED_MODULE_1___default()(input, {\r\n        initialCountry: \"auto\",\r\n        strictMode: false,\r\n        autoPlaceholder: \"aggressive\",\r\n        showSelectedDialCode: false,\r\n        utilsScript: \"../js/utils/mask/utils.js\", //ленивая загрузка\r\n        geoIpLookup: function (callback) {\r\n            fetch(\"https://ipapi.co/json\")\r\n                .then(function (res) { return res.json(); })\r\n                .then(function (data) { callback(data.country_code); })\r\n                .catch(function () { callback(); });\r\n        }\r\n    });\r\n\r\n    // Слушаем изменения в поле ввода номера телефона\r\n    input.addEventListener('input', function () {\r\n        var formattedNumber = intlTelInputUtils.formatNumber(iti.getNumber(), iti.getSelectedCountryData().iso2, iti.getSelectedCountryData().iso2 === 'ru' ? intlTelInputUtils.numberFormat.NATIONAL : intlTelInputUtils.numberFormat.INTERNATIONAL);\r\n        input.value = formattedNumber;\r\n    });\r\n};\r\n\r\n\r\n\r\n\n\n//# sourceURL=webpack://gut.tech/./html/js/utils/telMask.js?");

/***/ }),

/***/ "./node_modules/i18next-xhr-backend/dist/esm/i18nextXHRBackend.js":
/*!************************************************************************!*\
  !*** ./node_modules/i18next-xhr-backend/dist/esm/i18nextXHRBackend.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ \"./node_modules/@babel/runtime/helpers/esm/classCallCheck.js\");\n/* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ \"./node_modules/@babel/runtime/helpers/esm/createClass.js\");\n/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ \"./node_modules/@babel/runtime/helpers/esm/defineProperty.js\");\n/* harmony import */ var _babel_runtime_helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/esm/typeof */ \"./node_modules/@babel/runtime/helpers/esm/typeof.js\");\n\n\n\n\n\nvar arr = [];\nvar each = arr.forEach;\nvar slice = arr.slice;\nfunction defaults(obj) {\n  each.call(slice.call(arguments, 1), function (source) {\n    if (source) {\n      for (var prop in source) {\n        if (obj[prop] === undefined) obj[prop] = source[prop];\n      }\n    }\n  });\n  return obj;\n}\n\nfunction addQueryString(url, params) {\n  if (params && (0,_babel_runtime_helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(params) === 'object') {\n    var queryString = '',\n        e = encodeURIComponent; // Must encode data\n\n    for (var paramName in params) {\n      queryString += '&' + e(paramName) + '=' + e(params[paramName]);\n    }\n\n    if (!queryString) {\n      return url;\n    }\n\n    url = url + (url.indexOf('?') !== -1 ? '&' : '?') + queryString.slice(1);\n  }\n\n  return url;\n} // https://gist.github.com/Xeoncross/7663273\n\n\nfunction ajax(url, options, callback, data, cache) {\n  if (data && (0,_babel_runtime_helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(data) === 'object') {\n    if (!cache) {\n      data['_t'] = new Date();\n    } // URL encoded form data must be in querystring format\n\n\n    data = addQueryString('', data).slice(1);\n  }\n\n  if (options.queryStringParams) {\n    url = addQueryString(url, options.queryStringParams);\n  }\n\n  try {\n    var x;\n\n    if (XMLHttpRequest) {\n      x = new XMLHttpRequest();\n    } else {\n      x = new ActiveXObject('MSXML2.XMLHTTP.3.0');\n    }\n\n    x.open(data ? 'POST' : 'GET', url, 1);\n\n    if (!options.crossDomain) {\n      x.setRequestHeader('X-Requested-With', 'XMLHttpRequest');\n    }\n\n    x.withCredentials = !!options.withCredentials;\n\n    if (data) {\n      x.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');\n    }\n\n    if (x.overrideMimeType) {\n      x.overrideMimeType(\"application/json\");\n    }\n\n    var h = options.customHeaders;\n    h = typeof h === 'function' ? h() : h;\n\n    if (h) {\n      for (var i in h) {\n        x.setRequestHeader(i, h[i]);\n      }\n    }\n\n    x.onreadystatechange = function () {\n      x.readyState > 3 && callback && callback(x.responseText, x);\n    };\n\n    x.send(data);\n  } catch (e) {\n    console && console.log(e);\n  }\n}\n\nfunction getDefaults() {\n  return {\n    loadPath: '/locales/{{lng}}/{{ns}}.json',\n    addPath: '/locales/add/{{lng}}/{{ns}}',\n    allowMultiLoading: false,\n    parse: JSON.parse,\n    parsePayload: function parsePayload(namespace, key, fallbackValue) {\n      return (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({}, key, fallbackValue || '');\n    },\n    crossDomain: false,\n    ajax: ajax\n  };\n}\n\nvar Backend =\n/*#__PURE__*/\nfunction () {\n  function Backend(services) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    (0,_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, Backend);\n\n    this.init(services, options);\n    this.type = 'backend';\n  }\n\n  (0,_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(Backend, [{\n    key: \"init\",\n    value: function init(services) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      this.services = services;\n      this.options = defaults(options, this.options || {}, getDefaults());\n    }\n  }, {\n    key: \"readMulti\",\n    value: function readMulti(languages, namespaces, callback) {\n      var loadPath = this.options.loadPath;\n\n      if (typeof this.options.loadPath === 'function') {\n        loadPath = this.options.loadPath(languages, namespaces);\n      }\n\n      var url = this.services.interpolator.interpolate(loadPath, {\n        lng: languages.join('+'),\n        ns: namespaces.join('+')\n      });\n      this.loadUrl(url, callback);\n    }\n  }, {\n    key: \"read\",\n    value: function read(language, namespace, callback) {\n      var loadPath = this.options.loadPath;\n\n      if (typeof this.options.loadPath === 'function') {\n        loadPath = this.options.loadPath([language], [namespace]);\n      }\n\n      var url = this.services.interpolator.interpolate(loadPath, {\n        lng: language,\n        ns: namespace\n      });\n      this.loadUrl(url, callback);\n    }\n  }, {\n    key: \"loadUrl\",\n    value: function loadUrl(url, callback) {\n      var _this = this;\n\n      this.options.ajax(url, this.options, function (data, xhr) {\n        if (xhr.status >= 500 && xhr.status < 600) return callback('failed loading ' + url, true\n        /* retry */\n        );\n        if (xhr.status >= 400 && xhr.status < 500) return callback('failed loading ' + url, false\n        /* no retry */\n        );\n        var ret, err;\n\n        try {\n          ret = _this.options.parse(data, url);\n        } catch (e) {\n          err = 'failed parsing ' + url + ' to json';\n        }\n\n        if (err) return callback(err, false);\n        callback(null, ret);\n      });\n    }\n  }, {\n    key: \"create\",\n    value: function create(languages, namespace, key, fallbackValue) {\n      var _this2 = this;\n\n      if (typeof languages === 'string') languages = [languages];\n      var payload = this.options.parsePayload(namespace, key, fallbackValue);\n      languages.forEach(function (lng) {\n        var url = _this2.services.interpolator.interpolate(_this2.options.addPath, {\n          lng: lng,\n          ns: namespace\n        });\n\n        _this2.options.ajax(url, _this2.options, function (data, xhr) {//const statusCode = xhr.status.toString();\n          // TODO: if statusCode === 4xx do log\n        }, payload);\n      });\n    }\n  }]);\n\n  return Backend;\n}();\n\nBackend.type = 'backend';\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Backend);\n\n\n//# sourceURL=webpack://gut.tech/./node_modules/i18next-xhr-backend/dist/esm/i18nextXHRBackend.js?");

/***/ }),

/***/ "./node_modules/intl-tel-input/build/js/intlTelInput.js":
/*!**************************************************************!*\
  !*** ./node_modules/intl-tel-input/build/js/intlTelInput.js ***!
  \**************************************************************/
/***/ ((module) => {

eval("/*\n * International Telephone Input v20.3.0\n * https://github.com/jackocnr/intl-tel-input.git\n * Licensed under the MIT license\n */\n// wrap in UMD\n(function(factory) {\n    if ( true && module.exports) module.exports = factory(); else window.intlTelInput = factory();\n})(function(undefined) {\n    \"use strict\";\n    return function() {\n        // Array of country objects for the flag dropdown.\n        // Here is the criteria for the plugin to support a given country/territory\n        // - It has an iso2 code: https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2\n        // - It has it's own country calling code (it is not a sub-region of another country): https://en.wikipedia.org/wiki/List_of_country_calling_codes\n        // - It has a flag in the region-flags project: https://github.com/behdad/region-flags/tree/gh-pages/png\n        // - It is supported by libphonenumber (it must be listed on this page): https://github.com/googlei18n/libphonenumber/blob/master/resources/ShortNumberMetadata.xml\n        // Each country array has the following information:\n        // [\n        //    Country name,\n        //    iso2 code,\n        //    International dial code,\n        //    Order (if >1 country with same dial code),\n        //    Area codes\n        // ]\n        var allCountries = [ [ \"Afghanistan\", \"af\", \"93\" ], [ \"Albania\", \"al\", \"355\" ], [ \"Algeria\", \"dz\", \"213\" ], [ \"American Samoa\", \"as\", \"1\", 5, [ \"684\" ] ], [ \"Andorra\", \"ad\", \"376\" ], [ \"Angola\", \"ao\", \"244\" ], [ \"Anguilla\", \"ai\", \"1\", 6, [ \"264\" ] ], [ \"Antigua & Barbuda\", \"ag\", \"1\", 7, [ \"268\" ] ], [ \"Argentina\", \"ar\", \"54\" ], [ \"Armenia\", \"am\", \"374\" ], [ \"Aruba\", \"aw\", \"297\" ], [ \"Ascension Island\", \"ac\", \"247\" ], [ \"Australia\", \"au\", \"61\", 0 ], [ \"Austria\", \"at\", \"43\" ], [ \"Azerbaijan\", \"az\", \"994\" ], [ \"Bahamas\", \"bs\", \"1\", 8, [ \"242\" ] ], [ \"Bahrain\", \"bh\", \"973\" ], [ \"Bangladesh\", \"bd\", \"880\" ], [ \"Barbados\", \"bb\", \"1\", 9, [ \"246\" ] ], [ \"Belarus\", \"by\", \"375\" ], [ \"Belgium\", \"be\", \"32\" ], [ \"Belize\", \"bz\", \"501\" ], [ \"Benin\", \"bj\", \"229\" ], [ \"Bermuda\", \"bm\", \"1\", 10, [ \"441\" ] ], [ \"Bhutan\", \"bt\", \"975\" ], [ \"Bolivia\", \"bo\", \"591\" ], [ \"Bosnia & Herzegovina\", \"ba\", \"387\" ], [ \"Botswana\", \"bw\", \"267\" ], [ \"Brazil\", \"br\", \"55\" ], [ \"British Indian Ocean Territory\", \"io\", \"246\" ], [ \"British Virgin Islands\", \"vg\", \"1\", 11, [ \"284\" ] ], [ \"Brunei\", \"bn\", \"673\" ], [ \"Bulgaria\", \"bg\", \"359\" ], [ \"Burkina Faso\", \"bf\", \"226\" ], [ \"Burundi\", \"bi\", \"257\" ], [ \"Cambodia\", \"kh\", \"855\" ], [ \"Cameroon\", \"cm\", \"237\" ], [ \"Canada\", \"ca\", \"1\", 1, [ \"204\", \"226\", \"236\", \"249\", \"250\", \"263\", \"289\", \"306\", \"343\", \"354\", \"365\", \"367\", \"368\", \"382\", \"387\", \"403\", \"416\", \"418\", \"428\", \"431\", \"437\", \"438\", \"450\", \"584\", \"468\", \"474\", \"506\", \"514\", \"519\", \"548\", \"579\", \"581\", \"584\", \"587\", \"604\", \"613\", \"639\", \"647\", \"672\", \"683\", \"705\", \"709\", \"742\", \"753\", \"778\", \"780\", \"782\", \"807\", \"819\", \"825\", \"867\", \"873\", \"902\", \"905\" ] ], [ \"Cape Verde\", \"cv\", \"238\" ], [ \"Caribbean Netherlands\", \"bq\", \"599\", 1, [ \"3\", \"4\", \"7\" ] ], [ \"Cayman Islands\", \"ky\", \"1\", 12, [ \"345\" ] ], [ \"Central African Republic\", \"cf\", \"236\" ], [ \"Chad\", \"td\", \"235\" ], [ \"Chile\", \"cl\", \"56\" ], [ \"China\", \"cn\", \"86\" ], [ \"Christmas Island\", \"cx\", \"61\", 2, [ \"89164\" ] ], [ \"Cocos (Keeling) Islands\", \"cc\", \"61\", 1, [ \"89162\" ] ], [ \"Colombia\", \"co\", \"57\" ], [ \"Comoros\", \"km\", \"269\" ], [ \"Congo - Brazzaville\", \"cg\", \"242\" ], [ \"Congo - Kinshasa\", \"cd\", \"243\" ], [ \"Cook Islands\", \"ck\", \"682\" ], [ \"Costa Rica\", \"cr\", \"506\" ], [ \"Côte d’Ivoire\", \"ci\", \"225\" ], [ \"Croatia\", \"hr\", \"385\" ], [ \"Cuba\", \"cu\", \"53\" ], [ \"Curaçao\", \"cw\", \"599\", 0 ], [ \"Cyprus\", \"cy\", \"357\" ], [ \"Czech Republic\", \"cz\", \"420\" ], [ \"Denmark\", \"dk\", \"45\" ], [ \"Djibouti\", \"dj\", \"253\" ], [ \"Dominica\", \"dm\", \"1\", 13, [ \"767\" ] ], [ \"Dominican Republic\", \"do\", \"1\", 2, [ \"809\", \"829\", \"849\" ] ], [ \"Ecuador\", \"ec\", \"593\" ], [ \"Egypt\", \"eg\", \"20\" ], [ \"El Salvador\", \"sv\", \"503\" ], [ \"Equatorial Guinea\", \"gq\", \"240\" ], [ \"Eritrea\", \"er\", \"291\" ], [ \"Estonia\", \"ee\", \"372\" ], [ \"Eswatini\", \"sz\", \"268\" ], [ \"Ethiopia\", \"et\", \"251\" ], [ \"Falkland Islands\", \"fk\", \"500\" ], [ \"Faroe Islands\", \"fo\", \"298\" ], [ \"Fiji\", \"fj\", \"679\" ], [ \"Finland\", \"fi\", \"358\", 0 ], [ \"France\", \"fr\", \"33\" ], [ \"French Guiana\", \"gf\", \"594\" ], [ \"French Polynesia\", \"pf\", \"689\" ], [ \"Gabon\", \"ga\", \"241\" ], [ \"Gambia\", \"gm\", \"220\" ], [ \"Georgia\", \"ge\", \"995\" ], [ \"Germany\", \"de\", \"49\" ], [ \"Ghana\", \"gh\", \"233\" ], [ \"Gibraltar\", \"gi\", \"350\" ], [ \"Greece\", \"gr\", \"30\" ], [ \"Greenland\", \"gl\", \"299\" ], [ \"Grenada\", \"gd\", \"1\", 14, [ \"473\" ] ], [ \"Guadeloupe\", \"gp\", \"590\", 0 ], [ \"Guam\", \"gu\", \"1\", 15, [ \"671\" ] ], [ \"Guatemala\", \"gt\", \"502\" ], [ \"Guernsey\", \"gg\", \"44\", 1, [ \"1481\", \"7781\", \"7839\", \"7911\" ] ], [ \"Guinea\", \"gn\", \"224\" ], [ \"Guinea-Bissau\", \"gw\", \"245\" ], [ \"Guyana\", \"gy\", \"592\" ], [ \"Haiti\", \"ht\", \"509\" ], [ \"Honduras\", \"hn\", \"504\" ], [ \"Hong Kong\", \"hk\", \"852\" ], [ \"Hungary\", \"hu\", \"36\" ], [ \"Iceland\", \"is\", \"354\" ], [ \"India\", \"in\", \"91\" ], [ \"Indonesia\", \"id\", \"62\" ], [ \"Iran\", \"ir\", \"98\" ], [ \"Iraq\", \"iq\", \"964\" ], [ \"Ireland\", \"ie\", \"353\" ], [ \"Isle of Man\", \"im\", \"44\", 2, [ \"1624\", \"74576\", \"7524\", \"7924\", \"7624\" ] ], [ \"Israel\", \"il\", \"972\" ], [ \"Italy\", \"it\", \"39\", 0 ], [ \"Jamaica\", \"jm\", \"1\", 4, [ \"876\", \"658\" ] ], [ \"Japan\", \"jp\", \"81\" ], [ \"Jersey\", \"je\", \"44\", 3, [ \"1534\", \"7509\", \"7700\", \"7797\", \"7829\", \"7937\" ] ], [ \"Jordan\", \"jo\", \"962\" ], [ \"Kazakhstan\", \"kz\", \"7\", 1, [ \"33\", \"7\" ] ], [ \"Kenya\", \"ke\", \"254\" ], [ \"Kiribati\", \"ki\", \"686\" ], [ \"Kosovo\", \"xk\", \"383\" ], [ \"Kuwait\", \"kw\", \"965\" ], [ \"Kyrgyzstan\", \"kg\", \"996\" ], [ \"Laos\", \"la\", \"856\" ], [ \"Latvia\", \"lv\", \"371\" ], [ \"Lebanon\", \"lb\", \"961\" ], [ \"Lesotho\", \"ls\", \"266\" ], [ \"Liberia\", \"lr\", \"231\" ], [ \"Libya\", \"ly\", \"218\" ], [ \"Liechtenstein\", \"li\", \"423\" ], [ \"Lithuania\", \"lt\", \"370\" ], [ \"Luxembourg\", \"lu\", \"352\" ], [ \"Macau\", \"mo\", \"853\" ], [ \"Madagascar\", \"mg\", \"261\" ], [ \"Malawi\", \"mw\", \"265\" ], [ \"Malaysia\", \"my\", \"60\" ], [ \"Maldives\", \"mv\", \"960\" ], [ \"Mali\", \"ml\", \"223\" ], [ \"Malta\", \"mt\", \"356\" ], [ \"Marshall Islands\", \"mh\", \"692\" ], [ \"Martinique\", \"mq\", \"596\" ], [ \"Mauritania\", \"mr\", \"222\" ], [ \"Mauritius\", \"mu\", \"230\" ], [ \"Mayotte\", \"yt\", \"262\", 1, [ \"269\", \"639\" ] ], [ \"Mexico\", \"mx\", \"52\" ], [ \"Micronesia\", \"fm\", \"691\" ], [ \"Moldova\", \"md\", \"373\" ], [ \"Monaco\", \"mc\", \"377\" ], [ \"Mongolia\", \"mn\", \"976\" ], [ \"Montenegro\", \"me\", \"382\" ], [ \"Montserrat\", \"ms\", \"1\", 16, [ \"664\" ] ], [ \"Morocco\", \"ma\", \"212\", 0 ], [ \"Mozambique\", \"mz\", \"258\" ], [ \"Myanmar (Burma)\", \"mm\", \"95\" ], [ \"Namibia\", \"na\", \"264\" ], [ \"Nauru\", \"nr\", \"674\" ], [ \"Nepal\", \"np\", \"977\" ], [ \"Netherlands\", \"nl\", \"31\" ], [ \"New Caledonia\", \"nc\", \"687\" ], [ \"New Zealand\", \"nz\", \"64\" ], [ \"Nicaragua\", \"ni\", \"505\" ], [ \"Niger\", \"ne\", \"227\" ], [ \"Nigeria\", \"ng\", \"234\" ], [ \"Niue\", \"nu\", \"683\" ], [ \"Norfolk Island\", \"nf\", \"672\" ], [ \"North Korea\", \"kp\", \"850\" ], [ \"North Macedonia\", \"mk\", \"389\" ], [ \"Northern Mariana Islands\", \"mp\", \"1\", 17, [ \"670\" ] ], [ \"Norway\", \"no\", \"47\", 0 ], [ \"Oman\", \"om\", \"968\" ], [ \"Pakistan\", \"pk\", \"92\" ], [ \"Palau\", \"pw\", \"680\" ], [ \"Palestine\", \"ps\", \"970\" ], [ \"Panama\", \"pa\", \"507\" ], [ \"Papua New Guinea\", \"pg\", \"675\" ], [ \"Paraguay\", \"py\", \"595\" ], [ \"Peru\", \"pe\", \"51\" ], [ \"Philippines\", \"ph\", \"63\" ], [ \"Poland\", \"pl\", \"48\" ], [ \"Portugal\", \"pt\", \"351\" ], [ \"Puerto Rico\", \"pr\", \"1\", 3, [ \"787\", \"939\" ] ], [ \"Qatar\", \"qa\", \"974\" ], [ \"Réunion\", \"re\", \"262\", 0 ], [ \"Romania\", \"ro\", \"40\" ], [ \"Russia\", \"ru\", \"7\", 0 ], [ \"Rwanda\", \"rw\", \"250\" ], [ \"Samoa\", \"ws\", \"685\" ], [ \"San Marino\", \"sm\", \"378\" ], [ \"São Tomé & Príncipe\", \"st\", \"239\" ], [ \"Saudi Arabia\", \"sa\", \"966\" ], [ \"Senegal\", \"sn\", \"221\" ], [ \"Serbia\", \"rs\", \"381\" ], [ \"Seychelles\", \"sc\", \"248\" ], [ \"Sierra Leone\", \"sl\", \"232\" ], [ \"Singapore\", \"sg\", \"65\" ], [ \"Sint Maarten\", \"sx\", \"1\", 21, [ \"721\" ] ], [ \"Slovakia\", \"sk\", \"421\" ], [ \"Slovenia\", \"si\", \"386\" ], [ \"Solomon Islands\", \"sb\", \"677\" ], [ \"Somalia\", \"so\", \"252\" ], [ \"South Africa\", \"za\", \"27\" ], [ \"South Korea\", \"kr\", \"82\" ], [ \"South Sudan\", \"ss\", \"211\" ], [ \"Spain\", \"es\", \"34\" ], [ \"Sri Lanka\", \"lk\", \"94\" ], [ \"St Barthélemy\", \"bl\", \"590\", 1 ], [ \"St Helena\", \"sh\", \"290\" ], [ \"St Kitts & Nevis\", \"kn\", \"1\", 18, [ \"869\" ] ], [ \"St Lucia\", \"lc\", \"1\", 19, [ \"758\" ] ], [ \"St Martin\", \"mf\", \"590\", 2 ], [ \"St Pierre & Miquelon\", \"pm\", \"508\" ], [ \"St Vincent & Grenadines\", \"vc\", \"1\", 20, [ \"784\" ] ], [ \"Sudan\", \"sd\", \"249\" ], [ \"Suriname\", \"sr\", \"597\" ], [ \"Svalbard & Jan Mayen\", \"sj\", \"47\", 1, [ \"79\" ] ], [ \"Sweden\", \"se\", \"46\" ], [ \"Switzerland\", \"ch\", \"41\" ], [ \"Syria\", \"sy\", \"963\" ], [ \"Taiwan\", \"tw\", \"886\" ], [ \"Tajikistan\", \"tj\", \"992\" ], [ \"Tanzania\", \"tz\", \"255\" ], [ \"Thailand\", \"th\", \"66\" ], [ \"Timor-Leste\", \"tl\", \"670\" ], [ \"Togo\", \"tg\", \"228\" ], [ \"Tokelau\", \"tk\", \"690\" ], [ \"Tonga\", \"to\", \"676\" ], [ \"Trinidad & Tobago\", \"tt\", \"1\", 22, [ \"868\" ] ], [ \"Tunisia\", \"tn\", \"216\" ], [ \"Turkey\", \"tr\", \"90\" ], [ \"Turkmenistan\", \"tm\", \"993\" ], [ \"Turks & Caicos Islands\", \"tc\", \"1\", 23, [ \"649\" ] ], [ \"Tuvalu\", \"tv\", \"688\" ], [ \"Uganda\", \"ug\", \"256\" ], [ \"Ukraine\", \"ua\", \"380\" ], [ \"United Arab Emirates\", \"ae\", \"971\" ], [ \"United Kingdom\", \"gb\", \"44\", 0 ], [ \"United States\", \"us\", \"1\", 0 ], [ \"Uruguay\", \"uy\", \"598\" ], [ \"US Virgin Islands\", \"vi\", \"1\", 24, [ \"340\" ] ], [ \"Uzbekistan\", \"uz\", \"998\" ], [ \"Vanuatu\", \"vu\", \"678\" ], [ \"Vatican City\", \"va\", \"39\", 1, [ \"06698\" ] ], [ \"Venezuela\", \"ve\", \"58\" ], [ \"Vietnam\", \"vn\", \"84\" ], [ \"Wallis & Futuna\", \"wf\", \"681\" ], [ \"Western Sahara\", \"eh\", \"212\", 1, [ \"5288\", \"5289\" ] ], [ \"Yemen\", \"ye\", \"967\" ], [ \"Zambia\", \"zm\", \"260\" ], [ \"Zimbabwe\", \"zw\", \"263\" ], [ \"Åland Islands\", \"ax\", \"358\", 1, [ \"18\" ] ] ];\n        // loop over all of the countries above, restructuring the data to be objects with named keys\n        for (var i = 0; i < allCountries.length; i++) {\n            var c = allCountries[i];\n            allCountries[i] = {\n                name: c[0],\n                iso2: c[1],\n                dialCode: c[2],\n                priority: c[3] || 0,\n                areaCodes: c[4] || null,\n                nodeById: {}\n            };\n        }\n        const intlTelInputGlobals = {\n            getInstance: input => {\n                const id = input.getAttribute(\"data-intl-tel-input-id\");\n                return window.intlTelInputGlobals.instances[id];\n            },\n            instances: {},\n            // using a global like this allows us to mock it in the tests\n            documentReady: () => document.readyState === \"complete\"\n        };\n        if (typeof window === \"object\") {\n            window.intlTelInputGlobals = intlTelInputGlobals;\n        }\n        // these vars persist through all instances of the plugin\n        let id = 0;\n        const defaults = {\n            // whether or not to allow the dropdown\n            allowDropdown: true,\n            // add a placeholder in the input with an example number for the selected country\n            autoPlaceholder: \"polite\",\n            // add a country search input at the top of the dropdown\n            countrySearch: true,\n            // modify the parentClass\n            containerClass: \"\",\n            // modify the auto placeholder\n            customPlaceholder: null,\n            // append menu to specified element\n            dropdownContainer: null,\n            // don't display these countries\n            excludeCountries: [],\n            // fix the dropdown width to the input width (rather than being as wide as the longest country name)\n            fixDropdownWidth: true,\n            // format the number as the user types\n            formatAsYouType: true,\n            // format the input value during initialisation and on setNumber\n            formatOnDisplay: true,\n            // geoIp lookup function\n            geoIpLookup: null,\n            // inject a hidden input with the name returned from this function, and on submit, populate it with the result of getNumber\n            hiddenInput: null,\n            // internationalise the plugin text e.g. search input placeholder, country names\n            i18n: {},\n            // initial country\n            initialCountry: \"\",\n            // national vs international formatting for numbers e.g. placeholders and displaying existing numbers\n            nationalMode: true,\n            // display only these countries\n            onlyCountries: [],\n            // number type to use for placeholders\n            placeholderNumberType: \"MOBILE\",\n            // the countries at the top of the list\n            preferredCountries: [],\n            // option to hide the flags - must be used with showSelectedDialCode, or allowDropdown=false\n            showFlags: true,\n            // display the international dial code next to the selected flag\n            showSelectedDialCode: false,\n            // only allow certain chars e.g. a plus followed by numeric digits, and cap at max valid length\n            strictMode: false,\n            // use full screen popup instead of dropdown for country list\n            useFullscreenPopup: typeof navigator !== \"undefined\" && typeof window !== \"undefined\" ? // we cannot just test screen size as some smartphones/website meta tags will report desktop\n            // resolutions\n            // Note: to target Android Mobiles (and not Tablets), we must find 'Android' and 'Mobile'\n            /Android.+Mobile|webOS|iPhone|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth <= 500 : false,\n            // specify the path to the libphonenumber script to enable validation/formatting\n            utilsScript: \"\"\n        };\n        // https://en.wikipedia.org/wiki/List_of_North_American_Numbering_Plan_area_codes#Non-geographic_area_codes\n        const regionlessNanpNumbers = [ \"800\", \"822\", \"833\", \"844\", \"855\", \"866\", \"877\", \"880\", \"881\", \"882\", \"883\", \"884\", \"885\", \"886\", \"887\", \"888\", \"889\" ];\n        // run a method on each instance of the plugin\n        const forEachInstance = method => {\n            const {\n                instances\n            } = window.intlTelInputGlobals;\n            Object.values(instances).forEach(instance => instance[method]());\n        };\n        // this is our plugin class that we will create an instance of\n        // eslint-disable-next-line no-unused-vars\n        class Iti {\n            constructor(input, customOptions = {}) {\n                this.id = id++;\n                this.telInput = input;\n                this.activeItem = null;\n                this.highlightedItem = null;\n                // process specified options / defaults\n                this.options = Object.assign({}, defaults, customOptions);\n                this.hadInitialPlaceholder = Boolean(input.getAttribute(\"placeholder\"));\n            }\n            _init() {\n                // if showing fullscreen popup, do not fix the width\n                if (this.options.useFullscreenPopup) {\n                    this.options.fixDropdownWidth = false;\n                }\n                // when search enabled, we must fix the width else it would change with different results\n                if (this.options.countrySearch && !this.options.useFullscreenPopup) {\n                    this.options.fixDropdownWidth = true;\n                }\n                // force showFlags=true if there's a dropdown and we're not displaying the dial code,\n                // as otherwise you just have a down arrow on it's own which doesn't make sense\n                const forceShowFlags = this.options.allowDropdown && !this.options.showSelectedDialCode;\n                if (!this.options.showFlags && forceShowFlags) {\n                    this.options.showFlags = true;\n                }\n                // on mobile, we want a full screen dropdown, so we must append it to the body\n                if (this.options.useFullscreenPopup && !this.options.dropdownContainer) {\n                    this.options.dropdownContainer = document.body;\n                }\n                // check if input has one parent with RTL\n                this.isRTL = !!this.telInput.closest(\"[dir=rtl]\");\n                // these promises get resolved when their individual requests complete\n                // this way the dev can do something like iti.promise.then(...) to know when all requests are\n                // complete\n                const autoCountryPromise = new Promise((resolve, reject) => {\n                    this.resolveAutoCountryPromise = resolve;\n                    this.rejectAutoCountryPromise = reject;\n                });\n                const utilsScriptPromise = new Promise((resolve, reject) => {\n                    this.resolveUtilsScriptPromise = resolve;\n                    this.rejectUtilsScriptPromise = reject;\n                });\n                this.promise = Promise.all([ autoCountryPromise, utilsScriptPromise ]);\n                // in various situations there could be no country selected initially, but we need to be able\n                // to assume this variable exists\n                this.selectedCountryData = {};\n                // process all the data: onlyCountries, excludeCountries, preferredCountries etc\n                this._processCountryData();\n                // generate the markup\n                this._generateMarkup();\n                // set the initial state of the input value and the selected flag\n                this._setInitialState();\n                // start all of the event listeners: input keydown, selectedFlag click\n                this._initListeners();\n                // utils script, and auto country\n                this._initRequests();\n            }\n            /********************\n   *  PRIVATE METHODS\n   ********************/\n            // prepare all of the country data, including onlyCountries, excludeCountries and\n            // preferredCountries options\n            _processCountryData() {\n                // process onlyCountries or excludeCountries array if present\n                this._processAllCountries();\n                // generate this.dialCodes and this.dialCodeToIso2Map\n                this._processDialCodes();\n                // process the preferredCountries\n                this._processPreferredCountries();\n                // translate country names according to i18n option\n                this._translateCountryNames();\n                // sort countries by name\n                if (this.options.onlyCountries.length || this.options.i18n) {\n                    this.countries.sort(this._countryNameSort);\n                }\n            }\n            // add a dial code to this.dialCodeToIso2Map\n            _addToDialCodeMap(iso2, dialCode, priority) {\n                if (dialCode.length > this.dialCodeMaxLen) {\n                    this.dialCodeMaxLen = dialCode.length;\n                }\n                if (!this.dialCodeToIso2Map.hasOwnProperty(dialCode)) {\n                    this.dialCodeToIso2Map[dialCode] = [];\n                }\n                // bail if we already have this country for this dialCode\n                for (let i = 0; i < this.dialCodeToIso2Map[dialCode].length; i++) {\n                    if (this.dialCodeToIso2Map[dialCode][i] === iso2) {\n                        return;\n                    }\n                }\n                // check for undefined as 0 is falsy\n                const index = priority !== undefined ? priority : this.dialCodeToIso2Map[dialCode].length;\n                this.dialCodeToIso2Map[dialCode][index] = iso2;\n            }\n            // process onlyCountries or excludeCountries array if present\n            _processAllCountries() {\n                if (this.options.onlyCountries.length) {\n                    const lowerCaseOnlyCountries = this.options.onlyCountries.map(country => country.toLowerCase());\n                    this.countries = allCountries.filter(country => lowerCaseOnlyCountries.indexOf(country.iso2) > -1);\n                } else if (this.options.excludeCountries.length) {\n                    const lowerCaseExcludeCountries = this.options.excludeCountries.map(country => country.toLowerCase());\n                    this.countries = allCountries.filter(country => lowerCaseExcludeCountries.indexOf(country.iso2) === -1);\n                } else {\n                    this.countries = allCountries;\n                }\n            }\n            // Translate Countries by object literal provided on config\n            _translateCountryNames() {\n                for (let i = 0; i < this.countries.length; i++) {\n                    const iso2 = this.countries[i].iso2.toLowerCase();\n                    if (this.options.i18n.hasOwnProperty(iso2)) {\n                        this.countries[i].name = this.options.i18n[iso2];\n                    }\n                }\n            }\n            // sort by country name\n            _countryNameSort(a, b) {\n                if (a.name < b.name) {\n                    return -1;\n                }\n                if (a.name > b.name) {\n                    return 1;\n                }\n                return 0;\n            }\n            // generate this.dialCodes and this.dialCodeToIso2Map\n            _processDialCodes() {\n                // here we store just dial codes, where the key is the dial code, and the value is true\n                // e.g. { 1: true, 7: true, 20: true, ... }\n                this.dialCodes = {};\n                this.dialCodeMaxLen = 0;\n                // here we map dialCodes (inc both dialCode and dialCode+areaCode) to iso2 codes\n                /* e.g.\n     * {\n     *   1: [ 'us', 'ca', ... ],    # all NANP countries\n     *   12: [ 'us', 'ca', ... ],   # subset of NANP countries\n     *   120: [ 'us', 'ca' ],       # just US and Canada\n     *   1204: [ 'ca' ],            # only Canada\n     *   ...\n     *  }\n     */\n                this.dialCodeToIso2Map = {};\n                // first: add dial codes\n                for (let i = 0; i < this.countries.length; i++) {\n                    const c = this.countries[i];\n                    if (!this.dialCodes[c.dialCode]) {\n                        this.dialCodes[c.dialCode] = true;\n                    }\n                    this._addToDialCodeMap(c.iso2, c.dialCode, c.priority);\n                }\n                // next: add area codes\n                // this is a second loop over countries, to make sure we have all of the \"root\" countries\n                // already in the map, so that we can access them, as each time we add an area code substring\n                // to the map, we also need to include the \"root\" country's code, as that also matches\n                for (let i = 0; i < this.countries.length; i++) {\n                    const c = this.countries[i];\n                    // area codes\n                    if (c.areaCodes) {\n                        const rootIso2Code = this.dialCodeToIso2Map[c.dialCode][0];\n                        // for each area code\n                        for (let j = 0; j < c.areaCodes.length; j++) {\n                            const areaCode = c.areaCodes[j];\n                            // for each digit in the area code to add all partial matches as well\n                            for (let k = 1; k < areaCode.length; k++) {\n                                const partialDialCode = c.dialCode + areaCode.substr(0, k);\n                                // start with the root country, as that also matches this dial code\n                                this._addToDialCodeMap(rootIso2Code, partialDialCode);\n                                this._addToDialCodeMap(c.iso2, partialDialCode);\n                            }\n                            // add the full area code\n                            this._addToDialCodeMap(c.iso2, c.dialCode + areaCode);\n                        }\n                    }\n                }\n            }\n            // process preferred countries - iterate through the preferences, fetching the country data for\n            // each one\n            _processPreferredCountries() {\n                this.preferredCountries = [];\n                for (let i = 0; i < this.options.preferredCountries.length; i++) {\n                    const iso2 = this.options.preferredCountries[i].toLowerCase();\n                    const countryData = this._getCountryData(iso2, true);\n                    if (countryData) {\n                        this.preferredCountries.push(countryData);\n                    }\n                }\n            }\n            // create a DOM element\n            _createEl(name, attrs, container) {\n                const el = document.createElement(name);\n                if (attrs) {\n                    Object.entries(attrs).forEach(([ key, value ]) => el.setAttribute(key, value));\n                }\n                if (container) {\n                    container.appendChild(el);\n                }\n                return el;\n            }\n            // generate all of the markup for the plugin: the selected flag overlay, and the dropdown\n            _generateMarkup() {\n                this.telInput.classList.add(\"iti__tel-input\");\n                // if autocomplete does not exist on the element and its form, then\n                // prevent autocomplete as there's no safe, cross-browser event we can react to, so it can\n                // easily put the plugin in an inconsistent state e.g. the wrong flag selected for the\n                // autocompleted number, which on submit could mean wrong number is saved\n                if (!this.telInput.hasAttribute(\"autocomplete\") && !(this.telInput.form && this.telInput.form.hasAttribute(\"autocomplete\"))) {\n                    this.telInput.setAttribute(\"autocomplete\", \"off\");\n                }\n                const {\n                    allowDropdown,\n                    showSelectedDialCode,\n                    showFlags,\n                    containerClass,\n                    hiddenInput,\n                    dropdownContainer,\n                    fixDropdownWidth,\n                    useFullscreenPopup,\n                    countrySearch,\n                    i18n\n                } = this.options;\n                // containers (mostly for positioning)\n                let parentClass = \"iti\";\n                if (allowDropdown) {\n                    parentClass += \" iti--allow-dropdown\";\n                }\n                if (showSelectedDialCode) {\n                    parentClass += \" iti--show-selected-dial-code\";\n                }\n                if (showFlags) {\n                    parentClass += \" iti--show-flags\";\n                }\n                if (containerClass) {\n                    parentClass += ` ${containerClass}`;\n                }\n                if (!useFullscreenPopup) {\n                    parentClass += \" iti--inline-dropdown\";\n                }\n                const wrapper = this._createEl(\"div\", {\n                    class: parentClass\n                });\n                this.telInput.parentNode.insertBefore(wrapper, this.telInput);\n                // if we're showing flags or dial codes, we need the flags container etc\n                if (showFlags || showSelectedDialCode) {\n                    this.flagsContainer = this._createEl(\"div\", {\n                        class: \"iti__flag-container\"\n                    }, wrapper);\n                    // selected flag (displayed on left of input while allowDropdown is enabled, otherwise to right)\n                    // when countrySearch disabled: using Aria tags for \"Select-Only Combobox Example\"\n                    // https://www.w3.org/WAI/ARIA/apg/patterns/combobox/examples/combobox-select-only/\n                    this.selectedFlag = this._createEl(\"div\", {\n                        class: \"iti__selected-flag\",\n                        ...allowDropdown && {\n                            role: \"button\",\n                            \"aria-expanded\": \"false\",\n                            \"aria-label\": this.options.i18n.selectedCountryAriaLabel || \"Selected country\",\n                            \"aria-haspopup\": countrySearch ? \"true\" : \"listbox\",\n                            \"aria-controls\": countrySearch ? `iti-${this.id}__dropdown-content` : `iti-${this.id}__country-listbox`,\n                            ...countrySearch || {\n                                role: \"combobox\"\n                            }\n                        }\n                    }, this.flagsContainer);\n                    // we now include the selected flag element even when showFlags is disabled,\n                    // as need to show globe icon for showSelectedDialCode empty state\n                    this.selectedFlagInner = this._createEl(\"div\", null, this.selectedFlag);\n                    this.selectedFlagA11yText = this._createEl(\"span\", {\n                        class: \"iti__a11y-text\"\n                    }, this.selectedFlagInner);\n                }\n                wrapper.appendChild(this.telInput);\n                if (this.selectedFlag && this.telInput.disabled) {\n                    this.selectedFlag.setAttribute(\"aria-disabled\", \"true\");\n                }\n                if (showSelectedDialCode) {\n                    this.selectedDialCode = this._createEl(\"div\", {\n                        class: \"iti__selected-dial-code\"\n                    }, this.selectedFlag);\n                }\n                if (allowDropdown) {\n                    if (!this.telInput.disabled) {\n                        // make element focusable and tab navigable\n                        this.selectedFlag.setAttribute(\"tabindex\", \"0\");\n                    }\n                    this.dropdownArrow = this._createEl(\"div\", {\n                        class: \"iti__arrow\",\n                        \"aria-hidden\": \"true\"\n                    }, this.selectedFlag);\n                    const extraClasses = fixDropdownWidth ? \"\" : \"iti--flexible-dropdown-width\";\n                    this.dropdownContent = this._createEl(\"div\", {\n                        id: `iti-${this.id}__dropdown-content`,\n                        class: `iti__dropdown-content iti__hide ${extraClasses}`\n                    });\n                    if (countrySearch) {\n                        this.searchInput = this._createEl(\"input\", {\n                            type: \"text\",\n                            class: \"iti__search-input\",\n                            placeholder: i18n.searchPlaceholder || \"Search\",\n                            role: \"combobox\",\n                            \"aria-expanded\": \"true\",\n                            \"aria-label\": i18n.searchPlaceholder || \"Search\",\n                            \"aria-controls\": `iti-${this.id}__country-listbox`,\n                            \"aria-autocomplete\": \"list\",\n                            autocomplete: \"off\"\n                        }, this.dropdownContent);\n                        this.searchResultsA11yText = this._createEl(\"span\", {\n                            class: \"iti__a11y-text\"\n                        }, this.dropdownContent);\n                    }\n                    // country list: preferred countries, then divider, then all countries\n                    this.countryList = this._createEl(\"ul\", {\n                        class: \"iti__country-list\",\n                        id: `iti-${this.id}__country-listbox`,\n                        role: \"listbox\",\n                        \"aria-label\": i18n.countryListAriaLabel || \"List of countries\"\n                    }, this.dropdownContent);\n                    if (this.preferredCountries.length && !countrySearch) {\n                        this._appendListItems(this.preferredCountries, \"iti__preferred\", true);\n                        this._createEl(\"li\", {\n                            class: \"iti__divider\",\n                            \"aria-hidden\": \"true\"\n                        }, this.countryList);\n                    }\n                    this._appendListItems(this.countries, \"iti__standard\");\n                    if (countrySearch) {\n                        this._updateSearchResultsText();\n                    }\n                    // create dropdownContainer markup\n                    if (dropdownContainer) {\n                        let dropdownClasses = \"iti iti--container\";\n                        if (useFullscreenPopup) {\n                            dropdownClasses += \" iti--fullscreen-popup\";\n                        } else {\n                            dropdownClasses += \" iti--inline-dropdown\";\n                        }\n                        if (countrySearch) {\n                            dropdownClasses += \" iti--country-search\";\n                        }\n                        this.dropdown = this._createEl(\"div\", {\n                            class: dropdownClasses\n                        });\n                        this.dropdown.appendChild(this.dropdownContent);\n                    } else {\n                        this.flagsContainer.appendChild(this.dropdownContent);\n                    }\n                }\n                if (hiddenInput) {\n                    const telInputName = this.telInput.getAttribute(\"name\");\n                    const names = hiddenInput(telInputName);\n                    if (names.phone) {\n                        // Create hidden input for the full international number\n                        this.hiddenInput = this._createEl(\"input\", {\n                            type: \"hidden\",\n                            name: names.phone\n                        });\n                        wrapper.appendChild(this.hiddenInput);\n                    }\n                    if (names.country) {\n                        // Create hidden input for the selected country iso2 code\n                        this.hiddenInputCountry = this._createEl(\"input\", {\n                            type: \"hidden\",\n                            name: names.country\n                        });\n                        wrapper.appendChild(this.hiddenInputCountry);\n                    }\n                }\n            }\n            // for each of the passed countries: add a country <li> to the countryList <ul> container\n            _appendListItems(countries, className, preferred) {\n                for (let i = 0; i < countries.length; i++) {\n                    const c = countries[i];\n                    const idSuffix = preferred ? \"-preferred\" : \"\";\n                    const listItem = this._createEl(\"li\", {\n                        id: `iti-${this.id}__item-${c.iso2}${idSuffix}`,\n                        class: `iti__country ${className}`,\n                        tabindex: \"-1\",\n                        role: \"option\",\n                        \"data-dial-code\": c.dialCode,\n                        \"data-country-code\": c.iso2,\n                        \"aria-selected\": \"false\"\n                    }, this.countryList);\n                    // store this for later use e.g. country search filtering\n                    c.nodeById[this.id] = listItem;\n                    let content = \"\";\n                    // add the flag\n                    if (this.options.showFlags) {\n                        content += `<div class='iti__flag-box'><div class='iti__flag iti__${c.iso2}'></div></div>`;\n                    }\n                    // and the country name and dial code\n                    content += `<span class='iti__country-name'>${c.name}</span>`;\n                    content += `<span class='iti__dial-code'>+${c.dialCode}</span>`;\n                    listItem.insertAdjacentHTML(\"beforeend\", content);\n                }\n            }\n            // set the initial state of the input value and the selected flag by:\n            // 1. extracting a dial code from the given number\n            // 2. using explicit initialCountry\n            // 3. picking the first preferred country\n            // 4. picking the first country\n            _setInitialState(overrideAutoCountry = false) {\n                // fix firefox bug: when first load page (with input with value set to number with intl dial\n                // code) and initialising plugin removes the dial code from the input, then refresh page,\n                // and we try to init plugin again but this time on number without dial code so get grey flag\n                const attributeValue = this.telInput.getAttribute(\"value\");\n                const inputValue = this.telInput.value;\n                const useAttribute = attributeValue && attributeValue.charAt(0) === \"+\" && (!inputValue || inputValue.charAt(0) !== \"+\");\n                const val = useAttribute ? attributeValue : inputValue;\n                const dialCode = this._getDialCode(val);\n                const isRegionlessNanp = this._isRegionlessNanp(val);\n                const {\n                    initialCountry\n                } = this.options;\n                // if we already have a dial code, and it's not a regionlessNanp, we can go ahead and set the\n                // flag, else fall back to the default country\n                if (dialCode && !isRegionlessNanp) {\n                    this._updateFlagFromNumber(val);\n                } else if (initialCountry !== \"auto\" || overrideAutoCountry) {\n                    const lowerInitialCountry = initialCountry ? initialCountry.toLowerCase() : \"\";\n                    const isValidInitialCountry = lowerInitialCountry && this._getCountryData(lowerInitialCountry, true);\n                    // see if we should select a flag\n                    if (isValidInitialCountry) {\n                        this._setCountry(lowerInitialCountry);\n                    } else {\n                        if (dialCode && isRegionlessNanp) {\n                            // has intl dial code, is regionless nanp, and no initialCountry, so default to US\n                            this._setCountry(\"us\");\n                        } else {\n                            // display the empty state (globe icon)\n                            this._setCountry();\n                        }\n                    }\n                }\n                // NOTE: if initialCountry is set to auto, that will be handled separately\n                // format - note this wont be run after _updateDialCode as that's only called if no val\n                if (val) {\n                    this._updateValFromNumber(val);\n                }\n            }\n            // initialise the main event listeners: input keyup, and click selected flag\n            _initListeners() {\n                this._initTelInputListeners();\n                if (this.options.allowDropdown) {\n                    this._initDropdownListeners();\n                }\n                if ((this.hiddenInput || this.hiddenInputCountry) && this.telInput.form) {\n                    this._initHiddenInputListener();\n                }\n            }\n            // update hidden input on form submit\n            _initHiddenInputListener() {\n                this._handleHiddenInputSubmit = () => {\n                    if (this.hiddenInput) {\n                        this.hiddenInput.value = this.getNumber();\n                    }\n                    if (this.hiddenInputCountry) {\n                        this.hiddenInputCountry.value = this.getSelectedCountryData().iso2;\n                    }\n                };\n                this.telInput.form.addEventListener(\"submit\", this._handleHiddenInputSubmit);\n            }\n            // initialise the dropdown listeners\n            _initDropdownListeners() {\n                // hack for input nested inside label (which is valid markup): clicking the selected-flag to\n                // open the dropdown would then automatically trigger a 2nd click on the input which would\n                // close it again\n                this._handleLabelClick = e => {\n                    // if the dropdown is closed, then focus the input, else ignore the click\n                    if (this.dropdownContent.classList.contains(\"iti__hide\")) {\n                        this.telInput.focus();\n                    } else {\n                        e.preventDefault();\n                    }\n                };\n                const label = this.telInput.closest(\"label\");\n                if (label) {\n                    label.addEventListener(\"click\", this._handleLabelClick);\n                }\n                // toggle country dropdown on click\n                this._handleClickSelectedFlag = () => {\n                    // only intercept this event if we're opening the dropdown\n                    // else let it bubble up to the top (\"click-off-to-close\" listener)\n                    // we cannot just stopPropagation as it may be needed to close another instance\n                    if (this.dropdownContent.classList.contains(\"iti__hide\") && !this.telInput.disabled && !this.telInput.readOnly) {\n                        this._openDropdown();\n                    }\n                };\n                this.selectedFlag.addEventListener(\"click\", this._handleClickSelectedFlag);\n                // open dropdown if selected flag is focused and they press up/down/space/enter\n                this._handleFlagsContainerKeydown = e => {\n                    const isDropdownHidden = this.dropdownContent.classList.contains(\"iti__hide\");\n                    if (isDropdownHidden && [ \"ArrowUp\", \"ArrowDown\", \" \", \"Enter\" ].includes(e.key)) {\n                        // prevent form from being submitted if \"ENTER\" was pressed\n                        e.preventDefault();\n                        // prevent event from being handled again by document\n                        e.stopPropagation();\n                        this._openDropdown();\n                    }\n                    // allow navigation from dropdown to input on TAB\n                    if (e.key === \"Tab\") {\n                        this._closeDropdown();\n                    }\n                };\n                this.flagsContainer.addEventListener(\"keydown\", this._handleFlagsContainerKeydown);\n            }\n            // init many requests: utils script / geo ip lookup\n            _initRequests() {\n                // if the user has specified the path to the utils script, fetch it on window.load, else resolve\n                if (this.options.utilsScript && !window.intlTelInputUtils) {\n                    // if the plugin is being initialised after the window.load event has already been fired\n                    if (window.intlTelInputGlobals.documentReady()) {\n                        window.intlTelInputGlobals.loadUtils(this.options.utilsScript);\n                    } else {\n                        // wait until the load event so we don't block any other requests e.g. the flags image\n                        window.addEventListener(\"load\", () => {\n                            window.intlTelInputGlobals.loadUtils(this.options.utilsScript);\n                        });\n                    }\n                } else {\n                    this.resolveUtilsScriptPromise();\n                }\n                // dont bother with IP lookup if we already have a selected country\n                if (this.options.initialCountry === \"auto\" && !this.selectedCountryData.iso2) {\n                    this._loadAutoCountry();\n                } else {\n                    this.resolveAutoCountryPromise();\n                }\n            }\n            // perform the geo ip lookup\n            _loadAutoCountry() {\n                // 3 options:\n                // 1) already loaded (we're done)\n                // 2) not already started loading (start)\n                // 3) already started loading (do nothing - just wait for loading callback to fire)\n                if (window.intlTelInputGlobals.autoCountry) {\n                    this.handleAutoCountry();\n                } else if (!window.intlTelInputGlobals.startedLoadingAutoCountry) {\n                    // don't do this twice!\n                    window.intlTelInputGlobals.startedLoadingAutoCountry = true;\n                    if (typeof this.options.geoIpLookup === \"function\") {\n                        this.options.geoIpLookup((iso2 = \"\") => {\n                            const iso2Lower = iso2.toLowerCase();\n                            const isValidIso2 = iso2Lower && this._getCountryData(iso2Lower, true);\n                            if (isValidIso2) {\n                                window.intlTelInputGlobals.autoCountry = iso2Lower;\n                                // tell all instances the auto country is ready\n                                // TODO: this should just be the current instances\n                                // UPDATE: use setTimeout in case their geoIpLookup function calls this callback straight\n                                // away (e.g. if they have already done the geo ip lookup somewhere else). Using\n                                // setTimeout means that the current thread of execution will finish before executing\n                                // this, which allows the plugin to finish initialising.\n                                setTimeout(() => forEachInstance(\"handleAutoCountry\"));\n                            } else {\n                                this._setInitialState(true);\n                                forEachInstance(\"rejectAutoCountryPromise\");\n                            }\n                        }, () => forEachInstance(\"rejectAutoCountryPromise\"));\n                    }\n                }\n            }\n            // initialize the tel input listeners\n            _initTelInputListeners() {\n                const {\n                    strictMode,\n                    formatAsYouType\n                } = this.options;\n                let userOverrideFormatting = false;\n                // update flag on input event\n                this._handleInputEvent = e => {\n                    if (this._updateFlagFromNumber(this.telInput.value)) {\n                        this._triggerCountryChange();\n                    }\n                    // if user types their own formatting char (not a plus or a numeric), or they paste something, then set the override\n                    const isFormattingChar = e && e.data && /[^+0-9]/.test(e.data);\n                    const isPaste = e && e.inputType === \"insertFromPaste\" && this.telInput.value;\n                    if (isFormattingChar || isPaste && !strictMode) {\n                        userOverrideFormatting = true;\n                    }\n                    // if user removes all formatting chars, then reset the override\n                     else if (!/[^+0-9]/.test(this.telInput.value)) {\n                        userOverrideFormatting = false;\n                    }\n                    // handle FAYT, unless userOverrideFormatting\n                    if (formatAsYouType && !userOverrideFormatting) {\n                        // maintain caret position after reformatting\n                        const currentCaretPos = this.telInput.selectionStart;\n                        const valueBeforeCaret = this.telInput.value.substring(0, currentCaretPos);\n                        const relevantCharsBeforeCaret = valueBeforeCaret.replace(/[^+0-9]/g, \"\").length;\n                        const isDeleteForwards = e && e.inputType === \"deleteContentForward\";\n                        const formattedValue = this._formatNumberAsYouType();\n                        const newCaretPos = this._translateCursorPosition(relevantCharsBeforeCaret, formattedValue, currentCaretPos, isDeleteForwards);\n                        this.telInput.value = formattedValue;\n                        this.telInput.setSelectionRange(newCaretPos, newCaretPos);\n                    }\n                };\n                // this handles individual key presses as well as cut/paste events\n                // the advantage of the \"input\" event over \"keyup\" etc is that \"input\" only fires when the value changes,\n                // whereas \"keyup\" fires even for shift key, arrow key presses etc\n                this.telInput.addEventListener(\"input\", this._handleInputEvent);\n                if (strictMode) {\n                    this._handleKeydownEvent = e => {\n                        // only ignore actual character presses, rather than ctrl, alt, shift, command, arrow keys, delete/backspace, cut/copy/paste etc\n                        if (e.key.length === 1 && !e.altKey && !e.ctrlKey && !e.metaKey) {\n                            const isInitialPlus = this.telInput.selectionStart === 0 && e.key === \"+\";\n                            const isNumeric = /^[0-9]$/.test(e.key);\n                            const isAllowedChar = isInitialPlus || isNumeric;\n                            const fullNumber = this._getFullNumber();\n                            const coreNumber = intlTelInputUtils.getCoreNumber(fullNumber, this.selectedCountryData.iso2);\n                            const hasReachedMaxLength = this.maxCoreNumberLength && coreNumber.length >= this.maxCoreNumberLength;\n                            if (!isAllowedChar || hasReachedMaxLength) {\n                                e.preventDefault();\n                            }\n                        }\n                    };\n                    this.telInput.addEventListener(\"keydown\", this._handleKeydownEvent);\n                }\n            }\n            // iterate through the formattedValue until hit the right number of relevant chars\n            _translateCursorPosition(relevantChars, formattedValue, prevCaretPos, isDeleteForwards) {\n                // if the first char is a formatting char, and they backspace delete it:\n                // cursor should stay at the start (pos 0), rather than stick to the first digit (pos 1)\n                if (prevCaretPos === 0 && !isDeleteForwards) {\n                    return 0;\n                }\n                let count = 0;\n                for (let i = 0; i < formattedValue.length; i++) {\n                    if (/[+0-9]/.test(formattedValue[i])) {\n                        count++;\n                    }\n                    // normal case: stop when you hit the right number of relevant chars\n                    // (cursor will be just after the final relevant char)\n                    if (count === relevantChars && !isDeleteForwards) {\n                        return i + 1;\n                    }\n                    // spacial case: delete forwards (fn + delete on a mac):\n                    // wait until hit one extra relevant char, and put the cursor just before it (after any formatting chars)\n                    if (isDeleteForwards && count === relevantChars + 1) {\n                        return i;\n                    }\n                }\n                return formattedValue.length;\n            }\n            // adhere to the input's maxlength attr\n            _cap(number) {\n                const max = this.telInput.getAttribute(\"maxlength\");\n                return max && number.length > max ? number.substr(0, max) : number;\n            }\n            // clear the input if it just contains a dial code\n            _removeEmptyDialCode() {\n                if (this.telInput.value.charAt(0) === \"+\") {\n                    const numeric = this._getNumeric(this.telInput.value);\n                    // if just a plus, or if just a dial code\n                    if (!numeric || this.selectedCountryData.dialCode === numeric) {\n                        this.telInput.value = \"\";\n                    }\n                }\n            }\n            // extract the numeric digits from the given string\n            _getNumeric(s) {\n                return s.replace(/\\D/g, \"\");\n            }\n            // trigger a custom event on the input\n            _trigger(name) {\n                const e = new Event(name, {\n                    bubbles: true,\n                    cancelable: true\n                });\n                this.telInput.dispatchEvent(e);\n            }\n            // open the dropdown\n            _openDropdown() {\n                const {\n                    fixDropdownWidth,\n                    countrySearch\n                } = this.options;\n                if (fixDropdownWidth) {\n                    this.dropdownContent.style.width = `${this.telInput.offsetWidth}px`;\n                }\n                this.dropdownContent.classList.remove(\"iti__hide\");\n                this.selectedFlag.setAttribute(\"aria-expanded\", \"true\");\n                this._setDropdownPosition();\n                // if we have previously selected a country (and countrySearch is disabled), then highlight that item and scroll to it\n                // else highlight the first item and scroll to top (even if countrySearch is disabled e.g. on init, showing globe icon)\n                if (this.activeItem && !countrySearch) {\n                    // update highlighting and scroll to active list item\n                    this._highlightListItem(this.activeItem, false);\n                    this._scrollTo(this.activeItem, true);\n                } else {\n                    // start by highlighting the first item in the list\n                    const {\n                        firstElementChild\n                    } = this.countryList;\n                    if (firstElementChild) {\n                        this._highlightListItem(firstElementChild, false);\n                        this.countryList.scrollTop = 0;\n                    }\n                    if (countrySearch) {\n                        this.searchInput.focus();\n                    }\n                }\n                // bind all the dropdown-related listeners: mouseover, click, click-off, keydown\n                this._bindDropdownListeners();\n                // update the arrow\n                this.dropdownArrow.classList.add(\"iti__arrow--up\");\n                this._trigger(\"open:countrydropdown\");\n            }\n            // make sure the el has the className or not, depending on the value of shouldHaveClass\n            _toggleClass(el, className, shouldHaveClass) {\n                if (shouldHaveClass && !el.classList.contains(className)) {\n                    el.classList.add(className);\n                } else if (!shouldHaveClass && el.classList.contains(className)) {\n                    el.classList.remove(className);\n                }\n            }\n            // decide if should position dropdown above or below input (depends on position within viewport, and scroll)\n            _setDropdownPosition() {\n                if (this.options.dropdownContainer) {\n                    this.options.dropdownContainer.appendChild(this.dropdown);\n                }\n                if (!this.options.useFullscreenPopup) {\n                    const pos = this.telInput.getBoundingClientRect();\n                    // windowTop from https://stackoverflow.com/a/14384091/217866\n                    const windowTop = document.documentElement.scrollTop;\n                    const inputTop = pos.top + windowTop;\n                    const dropdownHeight = this.dropdownContent.offsetHeight;\n                    // dropdownFitsBelow = (dropdownBottom < windowBottom)\n                    const dropdownFitsBelow = inputTop + this.telInput.offsetHeight + dropdownHeight < windowTop + window.innerHeight;\n                    const dropdownFitsAbove = inputTop - dropdownHeight > windowTop;\n                    // dont allow positioning above when country search enabled as the search box jumps around as you filter countries\n                    const positionDropdownAboveInput = !this.options.countrySearch && !dropdownFitsBelow && dropdownFitsAbove;\n                    // by default, the dropdown will be below the input. If we want to position it above the\n                    // input, we add the dropup class.\n                    this._toggleClass(this.dropdownContent, \"iti__dropdown-content--dropup\", positionDropdownAboveInput);\n                    // if dropdownContainer is enabled, calculate postion\n                    if (this.options.dropdownContainer) {\n                        // if we want to position the dropdown below the input, we need to add the input height to the top value\n                        const extraTop = positionDropdownAboveInput ? 0 : this.telInput.offsetHeight;\n                        // calculate placement\n                        this.dropdown.style.top = `${inputTop + extraTop}px`;\n                        this.dropdown.style.left = `${pos.left + document.body.scrollLeft}px`;\n                        // close menu on window scroll\n                        this._handleWindowScroll = () => this._closeDropdown();\n                        window.addEventListener(\"scroll\", this._handleWindowScroll);\n                    }\n                }\n            }\n            // we only bind dropdown listeners when the dropdown is open\n            _bindDropdownListeners() {\n                // when mouse over a list item, just highlight that one\n                // we add the class \"highlight\", so if they hit \"enter\" we know which one to select\n                this._handleMouseoverCountryList = e => {\n                    // handle event delegation, as we're listening for this event on the countryList\n                    const listItem = e.target.closest(\".iti__country\");\n                    if (listItem) {\n                        this._highlightListItem(listItem, false);\n                    }\n                };\n                this.countryList.addEventListener(\"mouseover\", this._handleMouseoverCountryList);\n                // listen for country selection\n                this._handleClickCountryList = e => {\n                    const listItem = e.target.closest(\".iti__country\");\n                    if (listItem) {\n                        this._selectListItem(listItem);\n                    }\n                };\n                this.countryList.addEventListener(\"click\", this._handleClickCountryList);\n                // click off to close\n                // (except when this initial opening click is bubbling up)\n                // we cannot just stopPropagation as it may be needed to close another instance\n                let isOpening = true;\n                this._handleClickOffToClose = () => {\n                    if (!isOpening) {\n                        this._closeDropdown();\n                    }\n                    isOpening = false;\n                };\n                document.documentElement.addEventListener(\"click\", this._handleClickOffToClose);\n                // listen for up/down scrolling, enter to select, or escape to close\n                // use keydown as keypress doesn't fire for non-char keys and we want to catch if they\n                // just hit down and hold it to scroll down (no keyup event).\n                // listen on the document because that's where key events are triggered if no input has focus\n                let query = \"\";\n                let queryTimer = null;\n                this._handleKeydownOnDropdown = e => {\n                    // prevent down key from scrolling the whole page,\n                    // and enter key from submitting a form etc\n                    if ([ \"ArrowUp\", \"ArrowDown\", \"Enter\", \"Escape\" ].includes(e.key)) {\n                        e.preventDefault();\n                        e.stopPropagation();\n                        // up and down to navigate\n                        if (e.key === \"ArrowUp\" || e.key === \"ArrowDown\") {\n                            this._handleUpDownKey(e.key);\n                        }\n                        // enter to select\n                         else if (e.key === \"Enter\") {\n                            this._handleEnterKey();\n                        }\n                        // esc to close\n                         else if (e.key === \"Escape\") {\n                            this._closeDropdown();\n                        }\n                    }\n                    // alpha chars to perform search\n                    // regex allows one latin alpha char or space, based on https://stackoverflow.com/a/26900132/217866)\n                    if (!this.options.countrySearch && /^[a-zA-ZÀ-ÿа-яА-Я ]$/.test(e.key)) {\n                        e.stopPropagation();\n                        // jump to countries that start with the query string\n                        if (queryTimer) {\n                            clearTimeout(queryTimer);\n                        }\n                        query += e.key.toLowerCase();\n                        this._searchForCountry(query);\n                        // if the timer hits 1 second, reset the query\n                        queryTimer = setTimeout(() => {\n                            query = \"\";\n                        }, 1e3);\n                    }\n                };\n                document.addEventListener(\"keydown\", this._handleKeydownOnDropdown);\n                if (this.options.countrySearch) {\n                    const doFilter = () => {\n                        const inputQuery = this.searchInput.value.trim();\n                        if (inputQuery) {\n                            this._filterCountries(inputQuery);\n                        } else {\n                            this._filterCountries(\"\", true);\n                        }\n                    };\n                    let keyupTimer = null;\n                    this._handleSearchChange = () => {\n                        // filtering country nodes is expensive (lots of DOM manipulation), so rate limit it\n                        if (keyupTimer) {\n                            clearTimeout(keyupTimer);\n                        }\n                        keyupTimer = setTimeout(() => {\n                            doFilter();\n                            keyupTimer = null;\n                        }, 100);\n                    };\n                    this.searchInput.addEventListener(\"input\", this._handleSearchChange);\n                    // stop propagation on search input click, so doesn't trigger click-off-to-close listener\n                    this.searchInput.addEventListener(\"click\", e => e.stopPropagation());\n                }\n            }\n            // turns \"Réunion\" into \"Reunion\"\n            // from https://stackoverflow.com/a/37511463\n            _normaliseString(s = \"\") {\n                return s.normalize(\"NFD\").replace(/[\\u0300-\\u036f]/g, \"\").toLowerCase();\n            }\n            _filterCountries(query, isReset = false) {\n                let isFirst = true;\n                this.countryList.innerHTML = \"\";\n                const normalisedQuery = this._normaliseString(query);\n                for (let i = 0; i < this.countries.length; i++) {\n                    const c = this.countries[i];\n                    const normalisedCountryName = this._normaliseString(c.name);\n                    const fullDialCode = `+${c.dialCode}`;\n                    if (isReset || normalisedCountryName.includes(normalisedQuery) || fullDialCode.includes(normalisedQuery) || c.iso2.includes(normalisedQuery)) {\n                        this.countryList.appendChild(c.nodeById[this.id]);\n                        // highlight the first item\n                        if (isFirst) {\n                            this._highlightListItem(c.nodeById[this.id], false);\n                            isFirst = false;\n                        }\n                    }\n                }\n                // scroll to top (useful if user had previously scrolled down)\n                this.countryList.scrollTop = 0;\n                this._updateSearchResultsText();\n            }\n            // update search results text (for a11y)\n            _updateSearchResultsText() {\n                const {\n                    i18n\n                } = this.options;\n                const count = this.countryList.childElementCount;\n                let searchText;\n                if (count === 0) {\n                    searchText = i18n.zeroSearchResults || \"No results found\";\n                } else if (count === 1) {\n                    searchText = i18n.oneSearchResult || \"1 result found\";\n                } else {\n                    // eslint-disable-next-line no-template-curly-in-string\n                    searchText = i18n.multipleSearchResults ? i18n.multipleSearchResults.replace(\"${count}\", count) : `${count} results found`;\n                }\n                this.searchResultsA11yText.textContent = searchText;\n            }\n            // highlight the next/prev item in the list (and ensure it is visible)\n            _handleUpDownKey(key) {\n                let next = key === \"ArrowUp\" ? this.highlightedItem.previousElementSibling : this.highlightedItem.nextElementSibling;\n                if (next) {\n                    // skip the divider\n                    if (next.classList.contains(\"iti__divider\")) {\n                        next = key === \"ArrowUp\" ? next.previousElementSibling : next.nextElementSibling;\n                    }\n                } else if (this.countryList.childElementCount > 1) {\n                    // otherwise, we must be at the end, so loop round again\n                    next = key === \"ArrowUp\" ? this.countryList.lastElementChild : this.countryList.firstElementChild;\n                }\n                if (next) {\n                    // make sure the next item is visible\n                    // (before calling focus(), which can cause the next item to scroll to the middle of the dropdown, which is jarring)\n                    this._scrollTo(next, false);\n                    // if country search enabled, dont lose focus from the search input on up/down\n                    const doFocus = !this.options.countrySearch;\n                    this._highlightListItem(next, doFocus);\n                }\n            }\n            // select the currently highlighted item\n            _handleEnterKey() {\n                if (this.highlightedItem) {\n                    this._selectListItem(this.highlightedItem);\n                }\n            }\n            // find the first list item whose name starts with the query string\n            _searchForCountry(query) {\n                for (let i = 0; i < this.countries.length; i++) {\n                    if (this._startsWith(this.countries[i].name, query)) {\n                        const listItem = this.countries[i].nodeById[this.id];\n                        // update highlighting and scroll\n                        this._highlightListItem(listItem, false);\n                        this._scrollTo(listItem, true);\n                        break;\n                    }\n                }\n            }\n            // check if string a starts with string b\n            _startsWith(a, b) {\n                return a.substr(0, b.length).toLowerCase() === b;\n            }\n            // update the input's value to the given val (format first if possible)\n            // NOTE: this is called from _setInitialState, handleUtils and setNumber\n            _updateValFromNumber(fullNumber) {\n                let number = fullNumber;\n                if (this.options.formatOnDisplay && window.intlTelInputUtils && this.selectedCountryData) {\n                    const useNational = this.options.nationalMode || number.charAt(0) !== \"+\" && !this.options.showSelectedDialCode;\n                    const {\n                        NATIONAL,\n                        INTERNATIONAL\n                    } = intlTelInputUtils.numberFormat;\n                    const format = useNational ? NATIONAL : INTERNATIONAL;\n                    number = intlTelInputUtils.formatNumber(number, this.selectedCountryData.iso2, format);\n                }\n                number = this._beforeSetNumber(number);\n                this.telInput.value = number;\n            }\n            // check if need to select a new flag based on the given number\n            // Note: called from _setInitialState, keyup handler, setNumber\n            _updateFlagFromNumber(fullNumber) {\n                const plusIndex = fullNumber.indexOf(\"+\");\n                // if it contains a plus, discard any chars before it e.g. accidental space char.\n                // this keeps the selected country auto-updating correctly, which we want as\n                // libphonenumber's validation/getNumber methods will ignore these chars anyway\n                let number = plusIndex ? fullNumber.substring(plusIndex) : fullNumber;\n                // if we already have US/Canada selected, make sure the number starts\n                // with a +1 so _getDialCode will be able to extract the area code\n                // update: if we dont yet have selectedCountryData, but we're here (trying to update the flag\n                // from the number), that means we're initialising the plugin with a number that already has a\n                // dial code, so fine to ignore this bit\n                const selectedDialCode = this.selectedCountryData.dialCode;\n                const isNanp = selectedDialCode === \"1\";\n                if (number && isNanp && number.charAt(0) !== \"+\") {\n                    if (number.charAt(0) !== \"1\") {\n                        number = `1${number}`;\n                    }\n                    number = `+${number}`;\n                }\n                // if showSelectedDialCode enabled, then consider the selected dial code to be part of the number\n                if (this.options.showSelectedDialCode && selectedDialCode && number.charAt(0) !== \"+\") {\n                    number = `+${selectedDialCode}${number}`;\n                }\n                // try and extract valid dial code from input\n                const dialCode = this._getDialCode(number, true);\n                const numeric = this._getNumeric(number);\n                let iso2 = null;\n                if (dialCode) {\n                    const iso2Codes = this.dialCodeToIso2Map[this._getNumeric(dialCode)];\n                    // check if the right country is already selected. this should be false if the number is\n                    // longer than the matched dial code because in this case we need to make sure that if\n                    // there are multiple country matches, that the first one is selected (note: we could\n                    // just check that here, but it requires the same loop that we already have later)\n                    const alreadySelected = iso2Codes.indexOf(this.selectedCountryData.iso2) !== -1 && numeric.length <= dialCode.length - 1;\n                    const isRegionlessNanpNumber = selectedDialCode === \"1\" && this._isRegionlessNanp(numeric);\n                    // only update the flag if:\n                    // A) NOT (we currently have a NANP flag selected, and the number is a regionlessNanp)\n                    // AND\n                    // B) the right country is not already selected\n                    if (!isRegionlessNanpNumber && !alreadySelected) {\n                        // if using onlyCountries option, iso2Codes[0] may be empty, so we must find the first\n                        // non-empty index\n                        for (let j = 0; j < iso2Codes.length; j++) {\n                            if (iso2Codes[j]) {\n                                iso2 = iso2Codes[j];\n                                break;\n                            }\n                        }\n                    }\n                } else if (number.charAt(0) === \"+\" && numeric.length) {\n                    // invalid dial code, so empty\n                    // Note: use getNumeric here because the number has not been formatted yet, so could contain\n                    // bad chars\n                    iso2 = \"\";\n                } else if ((!number || number === \"+\") && !this.selectedCountryData.iso2) {\n                    // if no selected flag, and user either clears the input, or just types a plus, then show default\n                    iso2 = this.defaultCountry;\n                }\n                if (iso2 !== null) {\n                    return this._setCountry(iso2);\n                }\n                return false;\n            }\n            // check if the given number is a regionless NANP number (expects the number to contain an\n            // international dial code)\n            _isRegionlessNanp(number) {\n                const numeric = this._getNumeric(number);\n                if (numeric.charAt(0) === \"1\") {\n                    const areaCode = numeric.substr(1, 3);\n                    return regionlessNanpNumbers.indexOf(areaCode) !== -1;\n                }\n                return false;\n            }\n            // remove highlighting from other list items and highlight the given item\n            _highlightListItem(listItem, shouldFocus) {\n                const prevItem = this.highlightedItem;\n                if (prevItem) {\n                    prevItem.classList.remove(\"iti__highlight\");\n                    prevItem.setAttribute(\"aria-selected\", \"false\");\n                }\n                this.highlightedItem = listItem;\n                this.highlightedItem.classList.add(\"iti__highlight\");\n                this.highlightedItem.setAttribute(\"aria-selected\", \"true\");\n                this.selectedFlag.setAttribute(\"aria-activedescendant\", listItem.getAttribute(\"id\"));\n                if (this.options.countrySearch) {\n                    this.searchInput.setAttribute(\"aria-activedescendant\", listItem.getAttribute(\"id\"));\n                }\n                if (shouldFocus) {\n                    this.highlightedItem.focus();\n                }\n            }\n            // find the country data for the given iso2 code\n            // the ignoreOnlyCountriesOption is only used during init() while parsing the onlyCountries array\n            _getCountryData(iso2, allowFail) {\n                for (let i = 0; i < this.countries.length; i++) {\n                    if (this.countries[i].iso2 === iso2) {\n                        return this.countries[i];\n                    }\n                }\n                if (allowFail) {\n                    return null;\n                }\n                throw new Error(`No country data for '${iso2}'`);\n            }\n            // update the selected flag, dial code (if showSelectedDialCode), placeholder, title, and active list item\n            // Note: called from _setInitialState, _updateFlagFromNumber, _selectListItem, setCountry\n            _setCountry(iso2) {\n                const {\n                    allowDropdown,\n                    showSelectedDialCode,\n                    showFlags,\n                    countrySearch,\n                    i18n\n                } = this.options;\n                const prevCountry = this.selectedCountryData.iso2 ? this.selectedCountryData : {};\n                // do this first as it will throw an error and stop if iso2 is invalid\n                this.selectedCountryData = iso2 ? this._getCountryData(iso2, false) : {};\n                // update the defaultCountry - we only need the iso2 from now on, so just store that\n                if (this.selectedCountryData.iso2) {\n                    this.defaultCountry = this.selectedCountryData.iso2;\n                }\n                // update the flag class and the a11y text\n                if (this.selectedFlagInner) {\n                    let flagClass = \"\";\n                    let a11yText = \"\";\n                    if (iso2) {\n                        if (showFlags) {\n                            flagClass = `iti__flag iti__${iso2}`;\n                            a11yText = `${this.selectedCountryData.name} +${this.selectedCountryData.dialCode}`;\n                        }\n                        // if showFlags disabled and showSelectedDialCode is enabled, we dont show a flag or have any a11y text, as the displayed dial code is enough\n                    } else {\n                        flagClass = \"iti__flag iti__globe\";\n                        a11yText = i18n.noCountrySelected || \"No country selected\";\n                    }\n                    this.selectedFlagInner.className = flagClass;\n                    this.selectedFlagA11yText.textContent = a11yText;\n                }\n                this._setSelectedCountryFlagTitleAttribute(iso2, showSelectedDialCode);\n                // update the selected dial code\n                if (showSelectedDialCode) {\n                    const dialCode = this.selectedCountryData.dialCode ? `+${this.selectedCountryData.dialCode}` : \"\";\n                    this.selectedDialCode.innerHTML = dialCode;\n                    // offsetWidth is zero if input is in a hidden container during initialisation\n                    const selectedFlagWidth = this.selectedFlag.offsetWidth || this._getHiddenSelectedFlagWidth();\n                    // add 6px of padding after the grey selected-dial-code box, as this is what we use in the css\n                    if (this.isRTL) {\n                        this.telInput.style.paddingRight = `${selectedFlagWidth + 6}px`;\n                    } else {\n                        this.telInput.style.paddingLeft = `${selectedFlagWidth + 6}px`;\n                    }\n                }\n                // and the input's placeholder\n                this._updatePlaceholder();\n                // update the maximum valid number length\n                this._updateMaxLength();\n                // update the active list item (only if country search disabled, as country search doesn't store the active item)\n                if (allowDropdown && !countrySearch) {\n                    const prevItem = this.activeItem;\n                    if (prevItem) {\n                        prevItem.classList.remove(\"iti__active\");\n                        prevItem.setAttribute(\"aria-selected\", \"false\");\n                    }\n                    if (iso2) {\n                        // check if there is a preferred item first, else fall back to standard\n                        const nextItem = this.countryList.querySelector(`#iti-${this.id}__item-${iso2}-preferred`) || this.countryList.querySelector(`#iti-${this.id}__item-${iso2}`);\n                        nextItem.setAttribute(\"aria-selected\", \"true\");\n                        nextItem.classList.add(\"iti__active\");\n                        this.activeItem = nextItem;\n                    }\n                }\n                // return if the flag has changed or not\n                return prevCountry.iso2 !== iso2;\n            }\n            // update the maximum valid number length for the currently selected country\n            _updateMaxLength() {\n                if (this.options.strictMode && window.intlTelInputUtils) {\n                    if (this.selectedCountryData.iso2) {\n                        const numberType = intlTelInputUtils.numberType[this.options.placeholderNumberType];\n                        let exampleNumber = intlTelInputUtils.getExampleNumber(this.selectedCountryData.iso2, null, numberType, true);\n                        // see if adding more digits is still valid to get the true maximum valid length\n                        let validNumber = exampleNumber;\n                        while (intlTelInputUtils.isPossibleNumber(exampleNumber, this.selectedCountryData.iso2)) {\n                            validNumber = exampleNumber;\n                            exampleNumber += \"0\";\n                        }\n                        const coreNumber = intlTelInputUtils.getCoreNumber(validNumber, this.selectedCountryData.iso2);\n                        this.maxCoreNumberLength = coreNumber.length;\n                    } else {\n                        this.maxCoreNumberLength = null;\n                    }\n                }\n            }\n            _setSelectedCountryFlagTitleAttribute(iso2, showSelectedDialCode) {\n                if (!this.selectedFlag) {\n                    return;\n                }\n                let title;\n                if (iso2 && !showSelectedDialCode) {\n                    title = `${this.selectedCountryData.name}: +${this.selectedCountryData.dialCode}`;\n                } else if (iso2) {\n                    // For screen reader output, we don't want to include the dial code in the reader output twice\n                    // so just use the selected country name here:\n                    title = this.selectedCountryData.name;\n                } else {\n                    title = \"Unknown\";\n                }\n                this.selectedFlag.setAttribute(\"title\", title);\n            }\n            // when the input is in a hidden container during initialisation, we must inject some markup\n            // into the end of the DOM to calculate the correct offsetWidth\n            // NOTE: this is only used when showSelectedDialCode is enabled, so flagsContainer and selectedFlag\n            // will definitely exist\n            _getHiddenSelectedFlagWidth() {\n                // to get the right styling to apply, all we need is a shallow clone of the container,\n                // and then to inject a deep clone of the selectedFlag element\n                const containerClone = this.telInput.parentNode.cloneNode();\n                containerClone.style.visibility = \"hidden\";\n                document.body.appendChild(containerClone);\n                const flagsContainerClone = this.flagsContainer.cloneNode();\n                containerClone.appendChild(flagsContainerClone);\n                const selectedFlagClone = this.selectedFlag.cloneNode(true);\n                flagsContainerClone.appendChild(selectedFlagClone);\n                const width = selectedFlagClone.offsetWidth;\n                containerClone.parentNode.removeChild(containerClone);\n                return width;\n            }\n            // update the input placeholder to an example number from the currently selected country\n            _updatePlaceholder() {\n                const {\n                    autoPlaceholder,\n                    placeholderNumberType,\n                    nationalMode,\n                    customPlaceholder\n                } = this.options;\n                const shouldSetPlaceholder = autoPlaceholder === \"aggressive\" || !this.hadInitialPlaceholder && autoPlaceholder === \"polite\";\n                if (window.intlTelInputUtils && shouldSetPlaceholder) {\n                    const numberType = intlTelInputUtils.numberType[placeholderNumberType];\n                    // note: must set placeholder to empty string if no country selected (globe icon showing)\n                    let placeholder = this.selectedCountryData.iso2 ? intlTelInputUtils.getExampleNumber(this.selectedCountryData.iso2, nationalMode, numberType) : \"\";\n                    placeholder = this._beforeSetNumber(placeholder);\n                    if (typeof customPlaceholder === \"function\") {\n                        placeholder = customPlaceholder(placeholder, this.selectedCountryData);\n                    }\n                    this.telInput.setAttribute(\"placeholder\", placeholder);\n                }\n            }\n            // called when the user selects a list item from the dropdown\n            _selectListItem(listItem) {\n                // update selected flag and active list item\n                const flagChanged = this._setCountry(listItem.getAttribute(\"data-country-code\"));\n                this._closeDropdown();\n                this._updateDialCode(listItem.getAttribute(\"data-dial-code\"));\n                // focus the input\n                this.telInput.focus();\n                if (flagChanged) {\n                    this._triggerCountryChange();\n                }\n            }\n            // close the dropdown and unbind any listeners\n            _closeDropdown() {\n                this.dropdownContent.classList.add(\"iti__hide\");\n                this.selectedFlag.setAttribute(\"aria-expanded\", \"false\");\n                this.selectedFlag.removeAttribute(\"aria-activedescendant\");\n                if (this.highlightedItem) {\n                    this.highlightedItem.setAttribute(\"aria-selected\", \"false\");\n                }\n                if (this.options.countrySearch) {\n                    this.searchInput.removeAttribute(\"aria-activedescendant\");\n                }\n                // update the arrow\n                this.dropdownArrow.classList.remove(\"iti__arrow--up\");\n                // unbind key events\n                document.removeEventListener(\"keydown\", this._handleKeydownOnDropdown);\n                if (this.options.countrySearch) {\n                    this.searchInput.removeEventListener(\"input\", this._handleSearchChange);\n                }\n                document.documentElement.removeEventListener(\"click\", this._handleClickOffToClose);\n                this.countryList.removeEventListener(\"mouseover\", this._handleMouseoverCountryList);\n                this.countryList.removeEventListener(\"click\", this._handleClickCountryList);\n                // remove menu from container\n                if (this.options.dropdownContainer) {\n                    if (!this.options.useFullscreenPopup) {\n                        window.removeEventListener(\"scroll\", this._handleWindowScroll);\n                    }\n                    if (this.dropdown.parentNode) {\n                        this.dropdown.parentNode.removeChild(this.dropdown);\n                    }\n                }\n                this._trigger(\"close:countrydropdown\");\n            }\n            // check if an element is visible within it's container, else scroll until it is\n            _scrollTo(element, middle) {\n                const container = this.countryList;\n                // windowTop from https://stackoverflow.com/a/14384091/217866\n                const windowTop = document.documentElement.scrollTop;\n                const containerHeight = container.offsetHeight;\n                const containerTop = container.getBoundingClientRect().top + windowTop;\n                const containerBottom = containerTop + containerHeight;\n                const elementHeight = element.offsetHeight;\n                const elementTop = element.getBoundingClientRect().top + windowTop;\n                const elementBottom = elementTop + elementHeight;\n                let newScrollTop = elementTop - containerTop + container.scrollTop;\n                const middleOffset = containerHeight / 2 - elementHeight / 2;\n                if (elementTop < containerTop) {\n                    // scroll up\n                    if (middle) {\n                        newScrollTop -= middleOffset;\n                    }\n                    container.scrollTop = newScrollTop;\n                } else if (elementBottom > containerBottom) {\n                    // scroll down\n                    if (middle) {\n                        newScrollTop += middleOffset;\n                    }\n                    const heightDifference = containerHeight - elementHeight;\n                    container.scrollTop = newScrollTop - heightDifference;\n                }\n            }\n            // replace any existing dial code with the new one\n            // Note: called from _selectListItem and setCountry\n            _updateDialCode(newDialCodeBare) {\n                const inputVal = this.telInput.value;\n                // save having to pass this every time\n                const newDialCode = `+${newDialCodeBare}`;\n                let newNumber;\n                if (inputVal.charAt(0) === \"+\") {\n                    // there's a plus so we're dealing with a replacement\n                    const prevDialCode = this._getDialCode(inputVal);\n                    if (prevDialCode) {\n                        // current number contains a valid dial code, so replace it\n                        newNumber = inputVal.replace(prevDialCode, newDialCode);\n                    } else {\n                        // current number contains an invalid dial code, so ditch it\n                        // (no way to determine where the invalid dial code ends and the rest of the number begins)\n                        newNumber = newDialCode;\n                    }\n                    this.telInput.value = newNumber;\n                }\n            }\n            // try and extract a valid international dial code from a full telephone number\n            // Note: returns the raw string inc plus character and any whitespace/dots etc\n            _getDialCode(number, includeAreaCode) {\n                let dialCode = \"\";\n                // only interested in international numbers (starting with a plus)\n                if (number.charAt(0) === \"+\") {\n                    let numericChars = \"\";\n                    // iterate over chars\n                    for (let i = 0; i < number.length; i++) {\n                        const c = number.charAt(i);\n                        // if char is number (https://stackoverflow.com/a/8935649/217866)\n                        if (!isNaN(parseInt(c, 10))) {\n                            numericChars += c;\n                            // if current numericChars make a valid dial code\n                            if (includeAreaCode) {\n                                if (this.dialCodeToIso2Map[numericChars]) {\n                                    // store the actual raw string (useful for matching later)\n                                    dialCode = number.substr(0, i + 1);\n                                }\n                            } else {\n                                if (this.dialCodes[numericChars]) {\n                                    dialCode = number.substr(0, i + 1);\n                                    // if we're just looking for a dial code, we can break as soon as we find one\n                                    break;\n                                }\n                            }\n                            // stop searching as soon as we can - in this case when we hit max len\n                            if (numericChars.length === this.dialCodeMaxLen) {\n                                break;\n                            }\n                        }\n                    }\n                }\n                return dialCode;\n            }\n            // get the input val, adding the dial code if showSelectedDialCode is enabled\n            _getFullNumber() {\n                const val = this.telInput.value.trim();\n                const {\n                    dialCode\n                } = this.selectedCountryData;\n                let prefix;\n                const numericVal = this._getNumeric(val);\n                if (this.options.showSelectedDialCode && !this.options.nationalMode && val.charAt(0) !== \"+\" && dialCode && numericVal) {\n                    // when using showSelectedDialCode, it is visible so is effectively part of the typed number\n                    prefix = `+${dialCode}`;\n                } else {\n                    prefix = \"\";\n                }\n                return prefix + val;\n            }\n            // remove the dial code if showSelectedDialCode is enabled\n            // also cap the length if the input has a maxlength attribute\n            _beforeSetNumber(fullNumber) {\n                let number = fullNumber;\n                if (this.options.showSelectedDialCode) {\n                    let dialCode = this._getDialCode(number);\n                    // if there is a valid dial code\n                    if (dialCode) {\n                        // in case _getDialCode returned an area code as well\n                        dialCode = `+${this.selectedCountryData.dialCode}`;\n                        // a lot of numbers will have a space separating the dial code and the main number, and\n                        // some NANP numbers will have a hyphen e.g. +1 684-733-1234 - in both cases we want to get\n                        // rid of it\n                        // NOTE: don't just trim all non-numerics as may want to preserve an open parenthesis etc\n                        const start = number[dialCode.length] === \" \" || number[dialCode.length] === \"-\" ? dialCode.length + 1 : dialCode.length;\n                        number = number.substr(start);\n                    }\n                }\n                return this._cap(number);\n            }\n            // trigger the 'countrychange' event\n            _triggerCountryChange() {\n                this._trigger(\"countrychange\");\n            }\n            // format the number as the user types\n            _formatNumberAsYouType() {\n                const val = this._getFullNumber();\n                const result = window.intlTelInputUtils ? intlTelInputUtils.formatNumberAsYouType(val, this.selectedCountryData.iso2) : val;\n                // if showSelectedDialCode and they haven't (re)typed the dial code in the input as well, then remove the dial code\n                const {\n                    dialCode\n                } = this.selectedCountryData;\n                if (this.options.showSelectedDialCode && !this.options.nationalMode && this.telInput.value.charAt(0) !== \"+\" && result.includes(`+${dialCode}`)) {\n                    const afterDialCode = result.split(`+${dialCode}`)[1] || \"\";\n                    return afterDialCode.trim();\n                }\n                return result;\n            }\n            /**************************\n   *  SECRET PUBLIC METHODS\n   **************************/\n            // this is called when the geoip call returns\n            handleAutoCountry() {\n                if (this.options.initialCountry === \"auto\") {\n                    // we must set this even if there is an initial val in the input: in case the initial val is\n                    // invalid and they delete it - they should see their auto country\n                    this.defaultCountry = window.intlTelInputGlobals.autoCountry;\n                    // if there's no initial value in the input, then update the flag\n                    if (!this.telInput.value) {\n                        this.setCountry(this.defaultCountry);\n                    }\n                    this.resolveAutoCountryPromise();\n                }\n            }\n            // this is called when the utils request completes\n            handleUtils() {\n                // if the request was successful\n                if (window.intlTelInputUtils) {\n                    // if there's an initial value in the input, then format it\n                    if (this.telInput.value) {\n                        this._updateValFromNumber(this.telInput.value);\n                    }\n                    if (this.selectedCountryData.iso2) {\n                        this._updatePlaceholder();\n                        this._updateMaxLength();\n                    }\n                }\n                this.resolveUtilsScriptPromise();\n            }\n            /********************\n   *  PUBLIC METHODS\n   ********************/\n            // remove plugin\n            destroy() {\n                if (this.options.allowDropdown) {\n                    // make sure the dropdown is closed (and unbind listeners)\n                    this._closeDropdown();\n                    this.selectedFlag.removeEventListener(\"click\", this._handleClickSelectedFlag);\n                    this.flagsContainer.removeEventListener(\"keydown\", this._handleFlagsContainerKeydown);\n                    // label click hack\n                    const label = this.telInput.closest(\"label\");\n                    if (label) {\n                        label.removeEventListener(\"click\", this._handleLabelClick);\n                    }\n                }\n                // unbind hiddenInput listeners\n                const {\n                    form\n                } = this.telInput;\n                if (this._handleHiddenInputSubmit && form) {\n                    form.removeEventListener(\"submit\", this._handleHiddenInputSubmit);\n                }\n                // unbind key events, and cut/paste events\n                this.telInput.removeEventListener(\"input\", this._handleInputEvent);\n                if (this._handleKeydownEvent) {\n                    this.telInput.removeEventListener(\"keydown\", this._handleKeydownEvent);\n                }\n                // remove attribute of id instance: data-intl-tel-input-id\n                this.telInput.removeAttribute(\"data-intl-tel-input-id\");\n                // remove markup (but leave the original input)\n                const wrapper = this.telInput.parentNode;\n                wrapper.parentNode.insertBefore(this.telInput, wrapper);\n                wrapper.parentNode.removeChild(wrapper);\n                delete window.intlTelInputGlobals.instances[this.id];\n            }\n            // get the extension from the current number\n            getExtension() {\n                if (window.intlTelInputUtils) {\n                    return intlTelInputUtils.getExtension(this._getFullNumber(), this.selectedCountryData.iso2);\n                }\n                return \"\";\n            }\n            // format the number to the given format\n            getNumber(format) {\n                if (window.intlTelInputUtils) {\n                    const {\n                        iso2\n                    } = this.selectedCountryData;\n                    return intlTelInputUtils.formatNumber(this._getFullNumber(), iso2, format);\n                }\n                return \"\";\n            }\n            // get the type of the entered number e.g. landline/mobile\n            getNumberType() {\n                if (window.intlTelInputUtils) {\n                    return intlTelInputUtils.getNumberType(this._getFullNumber(), this.selectedCountryData.iso2);\n                }\n                return -99;\n            }\n            // get the country data for the currently selected flag\n            getSelectedCountryData() {\n                return this.selectedCountryData;\n            }\n            // get the validation error\n            getValidationError() {\n                if (window.intlTelInputUtils) {\n                    const {\n                        iso2\n                    } = this.selectedCountryData;\n                    return intlTelInputUtils.getValidationError(this._getFullNumber(), iso2);\n                }\n                return -99;\n            }\n            // validate the input val - assumes the global function isPossibleNumber (from utilsScript)\n            isValidNumber(mobileOnly = true) {\n                const val = this._getFullNumber();\n                // return false for any alpha chars\n                if (/\\p{L}/u.test(val)) {\n                    return false;\n                }\n                return window.intlTelInputUtils ? intlTelInputUtils.isPossibleNumber(val, this.selectedCountryData.iso2, mobileOnly) : null;\n            }\n            // validate the input val (precise) - assumes the global function isValidNumber (from utilsScript)\n            isValidNumberPrecise() {\n                const val = this._getFullNumber();\n                // return false for any alpha chars\n                if (/\\p{L}/u.test(val)) {\n                    return false;\n                }\n                return window.intlTelInputUtils ? intlTelInputUtils.isValidNumber(val, this.selectedCountryData.iso2) : null;\n            }\n            // update the selected flag, and update the input val accordingly\n            setCountry(iso2) {\n                const iso2Lower = iso2.toLowerCase();\n                // check if already selected\n                if (this.selectedCountryData.iso2 !== iso2Lower) {\n                    this._setCountry(iso2Lower);\n                    this._updateDialCode(this.selectedCountryData.dialCode);\n                    this._triggerCountryChange();\n                }\n            }\n            // set the input value and update the flag\n            setNumber(number) {\n                // we must update the flag first, which updates this.selectedCountryData, which is used for\n                // formatting the number before displaying it\n                const flagChanged = this._updateFlagFromNumber(number);\n                this._updateValFromNumber(number);\n                if (flagChanged) {\n                    this._triggerCountryChange();\n                }\n            }\n            // set the placeholder number typ\n            setPlaceholderNumberType(type) {\n                this.options.placeholderNumberType = type;\n                this._updatePlaceholder();\n            }\n        }\n        /********************\n *  STATIC METHODS\n ********************/\n        // get the country data object\n        intlTelInputGlobals.getCountryData = () => allCountries;\n        // inject a <script> element to load utils.js\n        const injectScript = (path, handleSuccess, handleFailure) => {\n            // inject a new script element into the page\n            const script = document.createElement(\"script\");\n            script.onload = () => {\n                forEachInstance(\"handleUtils\");\n                if (handleSuccess) {\n                    handleSuccess();\n                }\n            };\n            script.onerror = () => {\n                forEachInstance(\"rejectUtilsScriptPromise\");\n                if (handleFailure) {\n                    handleFailure();\n                }\n            };\n            script.className = \"iti-load-utils\";\n            script.async = true;\n            script.src = path;\n            document.body.appendChild(script);\n        };\n        // load the utils script\n        intlTelInputGlobals.loadUtils = path => {\n            // 2 options:\n            // 1) not already started loading (start)\n            // 2) already started loading (do nothing - just wait for the onload callback to fire, which will\n            // trigger handleUtils on all instances, invoking their resolveUtilsScriptPromise functions)\n            if (!window.intlTelInputUtils && !window.intlTelInputGlobals.startedLoadingUtilsScript) {\n                // only do this once\n                window.intlTelInputGlobals.startedLoadingUtilsScript = true;\n                return new Promise((resolve, reject) => injectScript(path, resolve, reject));\n            }\n            return null;\n        };\n        // default options\n        intlTelInputGlobals.defaults = defaults;\n        // version\n        intlTelInputGlobals.version = \"20.3.0\";\n        // convenience wrapper\n        return function(input, options) {\n            var iti = new Iti(input, options);\n            iti._init();\n            input.setAttribute(\"data-intl-tel-input-id\", iti.id);\n            window.intlTelInputGlobals.instances[iti.id] = iti;\n            return iti;\n        };\n    }();\n});\n\n//# sourceURL=webpack://gut.tech/./node_modules/intl-tel-input/build/js/intlTelInput.js?");

/***/ }),

/***/ "./node_modules/intl-tel-input/index.js":
/*!**********************************************!*\
  !*** ./node_modules/intl-tel-input/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ./build/js/intlTelInput */ \"./node_modules/intl-tel-input/build/js/intlTelInput.js\");\n\n\n//# sourceURL=webpack://gut.tech/./node_modules/intl-tel-input/index.js?");

/***/ }),

/***/ "./node_modules/loc-i18next/dist/commonjs/main.js":
/*!********************************************************!*\
  !*** ./node_modules/loc-i18next/dist/commonjs/main.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nvar defaults = {\n  selectorAttr: 'data-i18n',\n  targetAttr: 'i18n-target',\n  optionsAttr: 'i18n-options',\n  useOptionsAttr: false,\n  parseDefaultValueFromContent: true,\n  // `document` if running inside a browser, but otherwise undefined (prevents reference error when ran outside browser)\n  document: typeof window !== 'undefined' ? document : undefined\n};\nfunction init(i18next) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  options = _objectSpread({}, defaults, options);\n  var extendDefault = function extendDefault(o, val) {\n    return options.parseDefaultValueFromContent ? _objectSpread({}, o, {\n      defaultValue: val\n    }) : o;\n  };\n  function parse(elem, key, opts) {\n    var attr = 'text';\n    if (key.indexOf('[') == 0) {\n      var parts = key.split(']');\n      key = parts[1];\n      attr = parts[0].substr(1, parts[0].length - 1);\n    }\n    key = key.indexOf(';') == key.length - 1 ? key.substr(0, key.length - 2) : key;\n    if (attr === 'html') {\n      elem.innerHTML = i18next.t(key, extendDefault(opts, elem.innerHTML));\n    } else if (attr === 'text') {\n      elem.textContent = i18next.t(key, extendDefault(opts, elem.textContent));\n    } else if (attr === 'prepend') {\n      var startIdx = elem.innerHTML.indexOf('<loc-i18n>');\n      var endIdx = elem.innerHTML.indexOf('</loc-i18n>') + 11;\n      if (startIdx > -1 && endIdx > 6) {\n        elem.innerHTML = [elem.innerHTML.substring(0, startIdx), elem.innerHTML.slice(endIdx)].join('');\n      }\n      elem.innerHTML = ['<loc-i18n>', i18next.t(key, extendDefault(opts, elem.innerHTML)), '</loc-i18n>', elem.innerHTML].join('');\n    } else if (attr === 'append') {\n      var _startIdx = elem.innerHTML.indexOf('<loc-i18n>');\n      var _endIdx = elem.innerHTML.indexOf('</loc-i18n>') + 11;\n      if (_startIdx > -1 && _endIdx > 6) {\n        elem.innerHTML = [elem.innerHTML.substring(0, _startIdx), elem.innerHTML.slice(_endIdx)].join('');\n      }\n      elem.innerHTML = [elem.innerHTML, '<loc-i18n>', i18next.t(key, extendDefault(opts, elem.innerHTML), '</loc-i18n>')].join('');\n    } else if (attr.indexOf('data-') === 0) {\n      var dataAttr = attr.substr('data-'.length);\n      var translated = i18next.t(key, extendDefault(opts, elem.getAttribute(dataAttr)));\n      // we change into the data cache\n      elem.setAttribute(dataAttr, translated);\n      // we change into the dom\n      elem.setAttribute(attr, translated);\n    } else {\n      elem.setAttribute(attr, i18next.t(key, extendDefault(opts, elem.getAttribute(attr))));\n    }\n  }\n  ;\n  function relaxedJsonParse(badJSON) {\n    return JSON.parse(badJSON.replace(/:\\s*\"([^\"]*)\"/g, function (match, p1) {\n      return ': \"' + p1.replace(/:/g, '@colon@') + '\"';\n    }).replace(/:\\s*'([^']*)'/g, function (match, p1) {\n      return ': \"' + p1.replace(/:/g, '@colon@') + '\"';\n    }).replace(/(['\"])?([a-z0-9A-Z_]+)(['\"])?\\s*:/g, '\"$2\": ').replace(/@colon@/g, ':'));\n  }\n  function _loc(elem, opts) {\n    var key = elem.getAttribute(options.selectorAttr);\n    //        if (!key && typeof key !== 'undefined' && key !== false)\n    //            key = elem.textContent || elem.innerHTML;\n    if (!key) return;\n    var target = elem,\n      targetSelector = elem.getAttribute(options.targetAttr);\n    if (targetSelector != null) target = elem.querySelector(targetSelector) || elem;\n    if (!opts && options.useOptionsAttr === true) opts = relaxedJsonParse(elem.getAttribute(options.optionsAttr) || '{}');\n    opts = opts || {};\n    if (key.indexOf(';') >= 0) {\n      var keys = key.split(';');\n      for (var ix = 0, l_ix = keys.length; ix < l_ix; ix++) {\n        if (keys[ix] != '') parse(target, keys[ix], opts);\n      }\n    } else {\n      parse(target, key, opts);\n    }\n    if (options.useOptionsAttr === true) {\n      var clone = {};\n      clone = _objectSpread({\n        clone: clone\n      }, opts);\n      delete clone.lng;\n      elem.setAttribute(options.optionsAttr, JSON.stringify(clone));\n    }\n  }\n  function handle(selector, opts) {\n    var document = (opts === null || opts === void 0 ? void 0 : opts.document) || options.document;\n    var elems = document.querySelectorAll(selector);\n    for (var i = 0; i < elems.length; i++) {\n      var elem = elems[i];\n      var childs = elem.querySelectorAll('[' + options.selectorAttr + ']');\n      for (var j = childs.length - 1; j > -1; j--) {\n        _loc(childs[j], opts);\n      }\n      _loc(elem, opts);\n    }\n  }\n  ;\n  return handle;\n}\nvar _default = {\n  init: init\n};\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack://gut.tech/./node_modules/loc-i18next/dist/commonjs/main.js?");

/***/ }),

/***/ "./node_modules/loc-i18next/index.js":
/*!*******************************************!*\
  !*** ./node_modules/loc-i18next/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ./dist/commonjs/main.js */ \"./node_modules/loc-i18next/dist/commonjs/main.js\")[\"default\"];\n\n\n//# sourceURL=webpack://gut.tech/./node_modules/loc-i18next/index.js?");

/***/ }),

/***/ "./node_modules/animate.css/animate.css":
/*!**********************************************!*\
  !*** ./node_modules/animate.css/animate.css ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n\n\n//# sourceURL=webpack://gut.tech/./node_modules/animate.css/animate.css?");

/***/ }),

/***/ "./node_modules/intl-tel-input/build/css/intlTelInput.css":
/*!****************************************************************!*\
  !*** ./node_modules/intl-tel-input/build/css/intlTelInput.css ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n\n\n//# sourceURL=webpack://gut.tech/./node_modules/intl-tel-input/build/css/intlTelInput.css?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/classCallCheck.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ _classCallCheck)\n/* harmony export */ });\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\n//# sourceURL=webpack://gut.tech/./node_modules/@babel/runtime/helpers/esm/classCallCheck.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/createClass.js":
/*!****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/createClass.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ _createClass)\n/* harmony export */ });\n/* harmony import */ var _toPropertyKey_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./toPropertyKey.js */ \"./node_modules/@babel/runtime/helpers/esm/toPropertyKey.js\");\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, (0,_toPropertyKey_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(descriptor.key), descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\n\n//# sourceURL=webpack://gut.tech/./node_modules/@babel/runtime/helpers/esm/createClass.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/defineProperty.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ _defineProperty)\n/* harmony export */ });\n/* harmony import */ var _toPropertyKey_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./toPropertyKey.js */ \"./node_modules/@babel/runtime/helpers/esm/toPropertyKey.js\");\n\nfunction _defineProperty(obj, key, value) {\n  key = (0,_toPropertyKey_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\n//# sourceURL=webpack://gut.tech/./node_modules/@babel/runtime/helpers/esm/defineProperty.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/toPrimitive.js":
/*!****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/toPrimitive.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ toPrimitive)\n/* harmony export */ });\n/* harmony import */ var _typeof_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./typeof.js */ \"./node_modules/@babel/runtime/helpers/esm/typeof.js\");\n\nfunction toPrimitive(t, r) {\n  if (\"object\" != (0,_typeof_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(t) || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != (0,_typeof_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(i)) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\n\n//# sourceURL=webpack://gut.tech/./node_modules/@babel/runtime/helpers/esm/toPrimitive.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/toPropertyKey.js":
/*!******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/toPropertyKey.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ toPropertyKey)\n/* harmony export */ });\n/* harmony import */ var _typeof_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./typeof.js */ \"./node_modules/@babel/runtime/helpers/esm/typeof.js\");\n/* harmony import */ var _toPrimitive_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./toPrimitive.js */ \"./node_modules/@babel/runtime/helpers/esm/toPrimitive.js\");\n\n\nfunction toPropertyKey(t) {\n  var i = (0,_toPrimitive_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(t, \"string\");\n  return \"symbol\" == (0,_typeof_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(i) ? i : i + \"\";\n}\n\n//# sourceURL=webpack://gut.tech/./node_modules/@babel/runtime/helpers/esm/toPropertyKey.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/typeof.js":
/*!***********************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/typeof.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ _typeof)\n/* harmony export */ });\nfunction _typeof(o) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, _typeof(o);\n}\n\n//# sourceURL=webpack://gut.tech/./node_modules/@babel/runtime/helpers/esm/typeof.js?");

/***/ }),

/***/ "./node_modules/i18next-browser-languagedetector/dist/esm/i18nextBrowserLanguageDetector.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/i18next-browser-languagedetector/dist/esm/i18nextBrowserLanguageDetector.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Browser)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ \"./node_modules/@babel/runtime/helpers/esm/classCallCheck.js\");\n/* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ \"./node_modules/@babel/runtime/helpers/esm/createClass.js\");\n\n\n\nvar arr = [];\nvar each = arr.forEach;\nvar slice = arr.slice;\nfunction defaults(obj) {\n  each.call(slice.call(arguments, 1), function (source) {\n    if (source) {\n      for (var prop in source) {\n        if (obj[prop] === undefined) obj[prop] = source[prop];\n      }\n    }\n  });\n  return obj;\n}\n\n// eslint-disable-next-line no-control-regex\nvar fieldContentRegExp = /^[\\u0009\\u0020-\\u007e\\u0080-\\u00ff]+$/;\nvar serializeCookie = function serializeCookie(name, val, options) {\n  var opt = options || {};\n  opt.path = opt.path || '/';\n  var value = encodeURIComponent(val);\n  var str = \"\".concat(name, \"=\").concat(value);\n  if (opt.maxAge > 0) {\n    var maxAge = opt.maxAge - 0;\n    if (Number.isNaN(maxAge)) throw new Error('maxAge should be a Number');\n    str += \"; Max-Age=\".concat(Math.floor(maxAge));\n  }\n  if (opt.domain) {\n    if (!fieldContentRegExp.test(opt.domain)) {\n      throw new TypeError('option domain is invalid');\n    }\n    str += \"; Domain=\".concat(opt.domain);\n  }\n  if (opt.path) {\n    if (!fieldContentRegExp.test(opt.path)) {\n      throw new TypeError('option path is invalid');\n    }\n    str += \"; Path=\".concat(opt.path);\n  }\n  if (opt.expires) {\n    if (typeof opt.expires.toUTCString !== 'function') {\n      throw new TypeError('option expires is invalid');\n    }\n    str += \"; Expires=\".concat(opt.expires.toUTCString());\n  }\n  if (opt.httpOnly) str += '; HttpOnly';\n  if (opt.secure) str += '; Secure';\n  if (opt.sameSite) {\n    var sameSite = typeof opt.sameSite === 'string' ? opt.sameSite.toLowerCase() : opt.sameSite;\n    switch (sameSite) {\n      case true:\n        str += '; SameSite=Strict';\n        break;\n      case 'lax':\n        str += '; SameSite=Lax';\n        break;\n      case 'strict':\n        str += '; SameSite=Strict';\n        break;\n      case 'none':\n        str += '; SameSite=None';\n        break;\n      default:\n        throw new TypeError('option sameSite is invalid');\n    }\n  }\n  return str;\n};\nvar cookie = {\n  create: function create(name, value, minutes, domain) {\n    var cookieOptions = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {\n      path: '/',\n      sameSite: 'strict'\n    };\n    if (minutes) {\n      cookieOptions.expires = new Date();\n      cookieOptions.expires.setTime(cookieOptions.expires.getTime() + minutes * 60 * 1000);\n    }\n    if (domain) cookieOptions.domain = domain;\n    document.cookie = serializeCookie(name, encodeURIComponent(value), cookieOptions);\n  },\n  read: function read(name) {\n    var nameEQ = \"\".concat(name, \"=\");\n    var ca = document.cookie.split(';');\n    for (var i = 0; i < ca.length; i++) {\n      var c = ca[i];\n      while (c.charAt(0) === ' ') c = c.substring(1, c.length);\n      if (c.indexOf(nameEQ) === 0) return c.substring(nameEQ.length, c.length);\n    }\n    return null;\n  },\n  remove: function remove(name) {\n    this.create(name, '', -1);\n  }\n};\nvar cookie$1 = {\n  name: 'cookie',\n  lookup: function lookup(options) {\n    var found;\n    if (options.lookupCookie && typeof document !== 'undefined') {\n      var c = cookie.read(options.lookupCookie);\n      if (c) found = c;\n    }\n    return found;\n  },\n  cacheUserLanguage: function cacheUserLanguage(lng, options) {\n    if (options.lookupCookie && typeof document !== 'undefined') {\n      cookie.create(options.lookupCookie, lng, options.cookieMinutes, options.cookieDomain, options.cookieOptions);\n    }\n  }\n};\n\nvar querystring = {\n  name: 'querystring',\n  lookup: function lookup(options) {\n    var found;\n    if (typeof window !== 'undefined') {\n      var search = window.location.search;\n      if (!window.location.search && window.location.hash && window.location.hash.indexOf('?') > -1) {\n        search = window.location.hash.substring(window.location.hash.indexOf('?'));\n      }\n      var query = search.substring(1);\n      var params = query.split('&');\n      for (var i = 0; i < params.length; i++) {\n        var pos = params[i].indexOf('=');\n        if (pos > 0) {\n          var key = params[i].substring(0, pos);\n          if (key === options.lookupQuerystring) {\n            found = params[i].substring(pos + 1);\n          }\n        }\n      }\n    }\n    return found;\n  }\n};\n\nvar hasLocalStorageSupport = null;\nvar localStorageAvailable = function localStorageAvailable() {\n  if (hasLocalStorageSupport !== null) return hasLocalStorageSupport;\n  try {\n    hasLocalStorageSupport = window !== 'undefined' && window.localStorage !== null;\n    var testKey = 'i18next.translate.boo';\n    window.localStorage.setItem(testKey, 'foo');\n    window.localStorage.removeItem(testKey);\n  } catch (e) {\n    hasLocalStorageSupport = false;\n  }\n  return hasLocalStorageSupport;\n};\nvar localStorage = {\n  name: 'localStorage',\n  lookup: function lookup(options) {\n    var found;\n    if (options.lookupLocalStorage && localStorageAvailable()) {\n      var lng = window.localStorage.getItem(options.lookupLocalStorage);\n      if (lng) found = lng;\n    }\n    return found;\n  },\n  cacheUserLanguage: function cacheUserLanguage(lng, options) {\n    if (options.lookupLocalStorage && localStorageAvailable()) {\n      window.localStorage.setItem(options.lookupLocalStorage, lng);\n    }\n  }\n};\n\nvar hasSessionStorageSupport = null;\nvar sessionStorageAvailable = function sessionStorageAvailable() {\n  if (hasSessionStorageSupport !== null) return hasSessionStorageSupport;\n  try {\n    hasSessionStorageSupport = window !== 'undefined' && window.sessionStorage !== null;\n    var testKey = 'i18next.translate.boo';\n    window.sessionStorage.setItem(testKey, 'foo');\n    window.sessionStorage.removeItem(testKey);\n  } catch (e) {\n    hasSessionStorageSupport = false;\n  }\n  return hasSessionStorageSupport;\n};\nvar sessionStorage = {\n  name: 'sessionStorage',\n  lookup: function lookup(options) {\n    var found;\n    if (options.lookupSessionStorage && sessionStorageAvailable()) {\n      var lng = window.sessionStorage.getItem(options.lookupSessionStorage);\n      if (lng) found = lng;\n    }\n    return found;\n  },\n  cacheUserLanguage: function cacheUserLanguage(lng, options) {\n    if (options.lookupSessionStorage && sessionStorageAvailable()) {\n      window.sessionStorage.setItem(options.lookupSessionStorage, lng);\n    }\n  }\n};\n\nvar navigator$1 = {\n  name: 'navigator',\n  lookup: function lookup(options) {\n    var found = [];\n    if (typeof navigator !== 'undefined') {\n      if (navigator.languages) {\n        // chrome only; not an array, so can't use .push.apply instead of iterating\n        for (var i = 0; i < navigator.languages.length; i++) {\n          found.push(navigator.languages[i]);\n        }\n      }\n      if (navigator.userLanguage) {\n        found.push(navigator.userLanguage);\n      }\n      if (navigator.language) {\n        found.push(navigator.language);\n      }\n    }\n    return found.length > 0 ? found : undefined;\n  }\n};\n\nvar htmlTag = {\n  name: 'htmlTag',\n  lookup: function lookup(options) {\n    var found;\n    var htmlTag = options.htmlTag || (typeof document !== 'undefined' ? document.documentElement : null);\n    if (htmlTag && typeof htmlTag.getAttribute === 'function') {\n      found = htmlTag.getAttribute('lang');\n    }\n    return found;\n  }\n};\n\nvar path = {\n  name: 'path',\n  lookup: function lookup(options) {\n    var found;\n    if (typeof window !== 'undefined') {\n      var language = window.location.pathname.match(/\\/([a-zA-Z-]*)/g);\n      if (language instanceof Array) {\n        if (typeof options.lookupFromPathIndex === 'number') {\n          if (typeof language[options.lookupFromPathIndex] !== 'string') {\n            return undefined;\n          }\n          found = language[options.lookupFromPathIndex].replace('/', '');\n        } else {\n          found = language[0].replace('/', '');\n        }\n      }\n    }\n    return found;\n  }\n};\n\nvar subdomain = {\n  name: 'subdomain',\n  lookup: function lookup(options) {\n    // If given get the subdomain index else 1\n    var lookupFromSubdomainIndex = typeof options.lookupFromSubdomainIndex === 'number' ? options.lookupFromSubdomainIndex + 1 : 1;\n    // get all matches if window.location. is existing\n    // first item of match is the match itself and the second is the first group macht which sould be the first subdomain match\n    // is the hostname no public domain get the or option of localhost\n    var language = typeof window !== 'undefined' && window.location && window.location.hostname && window.location.hostname.match(/^(\\w{2,5})\\.(([a-z0-9-]{1,63}\\.[a-z]{2,6})|localhost)/i);\n\n    // if there is no match (null) return undefined\n    if (!language) return undefined;\n    // return the given group match\n    return language[lookupFromSubdomainIndex];\n  }\n};\n\nfunction getDefaults() {\n  return {\n    order: ['querystring', 'cookie', 'localStorage', 'sessionStorage', 'navigator', 'htmlTag'],\n    lookupQuerystring: 'lng',\n    lookupCookie: 'i18next',\n    lookupLocalStorage: 'i18nextLng',\n    lookupSessionStorage: 'i18nextLng',\n    // cache user language\n    caches: ['localStorage'],\n    excludeCacheFor: ['cimode'],\n    // cookieMinutes: 10,\n    // cookieDomain: 'myDomain'\n\n    convertDetectedLanguage: function convertDetectedLanguage(l) {\n      return l;\n    }\n  };\n}\nvar Browser = /*#__PURE__*/function () {\n  function Browser(services) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    (0,_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, Browser);\n    this.type = 'languageDetector';\n    this.detectors = {};\n    this.init(services, options);\n  }\n  (0,_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(Browser, [{\n    key: \"init\",\n    value: function init(services) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var i18nOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      this.services = services || {\n        languageUtils: {}\n      }; // this way the language detector can be used without i18next\n      this.options = defaults(options, this.options || {}, getDefaults());\n      if (typeof this.options.convertDetectedLanguage === 'string' && this.options.convertDetectedLanguage.indexOf('15897') > -1) {\n        this.options.convertDetectedLanguage = function (l) {\n          return l.replace('-', '_');\n        };\n      }\n\n      // backwards compatibility\n      if (this.options.lookupFromUrlIndex) this.options.lookupFromPathIndex = this.options.lookupFromUrlIndex;\n      this.i18nOptions = i18nOptions;\n      this.addDetector(cookie$1);\n      this.addDetector(querystring);\n      this.addDetector(localStorage);\n      this.addDetector(sessionStorage);\n      this.addDetector(navigator$1);\n      this.addDetector(htmlTag);\n      this.addDetector(path);\n      this.addDetector(subdomain);\n    }\n  }, {\n    key: \"addDetector\",\n    value: function addDetector(detector) {\n      this.detectors[detector.name] = detector;\n    }\n  }, {\n    key: \"detect\",\n    value: function detect(detectionOrder) {\n      var _this = this;\n      if (!detectionOrder) detectionOrder = this.options.order;\n      var detected = [];\n      detectionOrder.forEach(function (detectorName) {\n        if (_this.detectors[detectorName]) {\n          var lookup = _this.detectors[detectorName].lookup(_this.options);\n          if (lookup && typeof lookup === 'string') lookup = [lookup];\n          if (lookup) detected = detected.concat(lookup);\n        }\n      });\n      detected = detected.map(function (d) {\n        return _this.options.convertDetectedLanguage(d);\n      });\n      if (this.services.languageUtils.getBestMatchFromCodes) return detected; // new i18next v19.5.0\n      return detected.length > 0 ? detected[0] : null; // a little backward compatibility\n    }\n  }, {\n    key: \"cacheUserLanguage\",\n    value: function cacheUserLanguage(lng, caches) {\n      var _this2 = this;\n      if (!caches) caches = this.options.caches;\n      if (!caches) return;\n      if (this.options.excludeCacheFor && this.options.excludeCacheFor.indexOf(lng) > -1) return;\n      caches.forEach(function (cacheName) {\n        if (_this2.detectors[cacheName]) _this2.detectors[cacheName].cacheUserLanguage(lng, _this2.options);\n      });\n    }\n  }]);\n  return Browser;\n}();\nBrowser.type = 'languageDetector';\n\n\n\n\n//# sourceURL=webpack://gut.tech/./node_modules/i18next-browser-languagedetector/dist/esm/i18nextBrowserLanguageDetector.js?");

/***/ }),

/***/ "./node_modules/i18next/dist/esm/i18next.js":
/*!**************************************************!*\
  !*** ./node_modules/i18next/dist/esm/i18next.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   changeLanguage: () => (/* binding */ changeLanguage),\n/* harmony export */   createInstance: () => (/* binding */ createInstance),\n/* harmony export */   \"default\": () => (/* binding */ instance),\n/* harmony export */   dir: () => (/* binding */ dir),\n/* harmony export */   exists: () => (/* binding */ exists),\n/* harmony export */   getFixedT: () => (/* binding */ getFixedT),\n/* harmony export */   hasLoadedNamespace: () => (/* binding */ hasLoadedNamespace),\n/* harmony export */   init: () => (/* binding */ init),\n/* harmony export */   loadLanguages: () => (/* binding */ loadLanguages),\n/* harmony export */   loadNamespaces: () => (/* binding */ loadNamespaces),\n/* harmony export */   loadResources: () => (/* binding */ loadResources),\n/* harmony export */   reloadResources: () => (/* binding */ reloadResources),\n/* harmony export */   setDefaultNamespace: () => (/* binding */ setDefaultNamespace),\n/* harmony export */   t: () => (/* binding */ t),\n/* harmony export */   use: () => (/* binding */ use)\n/* harmony export */ });\nconst consoleLogger = {\n  type: 'logger',\n  log(args) {\n    this.output('log', args);\n  },\n  warn(args) {\n    this.output('warn', args);\n  },\n  error(args) {\n    this.output('error', args);\n  },\n  output(type, args) {\n    if (console && console[type]) console[type].apply(console, args);\n  }\n};\nclass Logger {\n  constructor(concreteLogger) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.init(concreteLogger, options);\n  }\n  init(concreteLogger) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.prefix = options.prefix || 'i18next:';\n    this.logger = concreteLogger || consoleLogger;\n    this.options = options;\n    this.debug = options.debug;\n  }\n  log() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    return this.forward(args, 'log', '', true);\n  }\n  warn() {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n    return this.forward(args, 'warn', '', true);\n  }\n  error() {\n    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      args[_key3] = arguments[_key3];\n    }\n    return this.forward(args, 'error', '');\n  }\n  deprecate() {\n    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      args[_key4] = arguments[_key4];\n    }\n    return this.forward(args, 'warn', 'WARNING DEPRECATED: ', true);\n  }\n  forward(args, lvl, prefix, debugOnly) {\n    if (debugOnly && !this.debug) return null;\n    if (typeof args[0] === 'string') args[0] = `${prefix}${this.prefix} ${args[0]}`;\n    return this.logger[lvl](args);\n  }\n  create(moduleName) {\n    return new Logger(this.logger, {\n      ...{\n        prefix: `${this.prefix}:${moduleName}:`\n      },\n      ...this.options\n    });\n  }\n  clone(options) {\n    options = options || this.options;\n    options.prefix = options.prefix || this.prefix;\n    return new Logger(this.logger, options);\n  }\n}\nvar baseLogger = new Logger();\n\nclass EventEmitter {\n  constructor() {\n    this.observers = {};\n  }\n  on(events, listener) {\n    events.split(' ').forEach(event => {\n      if (!this.observers[event]) this.observers[event] = new Map();\n      const numListeners = this.observers[event].get(listener) || 0;\n      this.observers[event].set(listener, numListeners + 1);\n    });\n    return this;\n  }\n  off(event, listener) {\n    if (!this.observers[event]) return;\n    if (!listener) {\n      delete this.observers[event];\n      return;\n    }\n    this.observers[event].delete(listener);\n  }\n  emit(event) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n    if (this.observers[event]) {\n      const cloned = Array.from(this.observers[event].entries());\n      cloned.forEach(_ref => {\n        let [observer, numTimesAdded] = _ref;\n        for (let i = 0; i < numTimesAdded; i++) {\n          observer(...args);\n        }\n      });\n    }\n    if (this.observers['*']) {\n      const cloned = Array.from(this.observers['*'].entries());\n      cloned.forEach(_ref2 => {\n        let [observer, numTimesAdded] = _ref2;\n        for (let i = 0; i < numTimesAdded; i++) {\n          observer.apply(observer, [event, ...args]);\n        }\n      });\n    }\n  }\n}\n\nfunction defer() {\n  let res;\n  let rej;\n  const promise = new Promise((resolve, reject) => {\n    res = resolve;\n    rej = reject;\n  });\n  promise.resolve = res;\n  promise.reject = rej;\n  return promise;\n}\nfunction makeString(object) {\n  if (object == null) return '';\n  return '' + object;\n}\nfunction copy(a, s, t) {\n  a.forEach(m => {\n    if (s[m]) t[m] = s[m];\n  });\n}\nconst lastOfPathSeparatorRegExp = /###/g;\nfunction getLastOfPath(object, path, Empty) {\n  function cleanKey(key) {\n    return key && key.indexOf('###') > -1 ? key.replace(lastOfPathSeparatorRegExp, '.') : key;\n  }\n  function canNotTraverseDeeper() {\n    return !object || typeof object === 'string';\n  }\n  const stack = typeof path !== 'string' ? path : path.split('.');\n  let stackIndex = 0;\n  while (stackIndex < stack.length - 1) {\n    if (canNotTraverseDeeper()) return {};\n    const key = cleanKey(stack[stackIndex]);\n    if (!object[key] && Empty) object[key] = new Empty();\n    if (Object.prototype.hasOwnProperty.call(object, key)) {\n      object = object[key];\n    } else {\n      object = {};\n    }\n    ++stackIndex;\n  }\n  if (canNotTraverseDeeper()) return {};\n  return {\n    obj: object,\n    k: cleanKey(stack[stackIndex])\n  };\n}\nfunction setPath(object, path, newValue) {\n  const {\n    obj,\n    k\n  } = getLastOfPath(object, path, Object);\n  if (obj !== undefined || path.length === 1) {\n    obj[k] = newValue;\n    return;\n  }\n  let e = path[path.length - 1];\n  let p = path.slice(0, path.length - 1);\n  let last = getLastOfPath(object, p, Object);\n  while (last.obj === undefined && p.length) {\n    e = `${p[p.length - 1]}.${e}`;\n    p = p.slice(0, p.length - 1);\n    last = getLastOfPath(object, p, Object);\n    if (last && last.obj && typeof last.obj[`${last.k}.${e}`] !== 'undefined') {\n      last.obj = undefined;\n    }\n  }\n  last.obj[`${last.k}.${e}`] = newValue;\n}\nfunction pushPath(object, path, newValue, concat) {\n  const {\n    obj,\n    k\n  } = getLastOfPath(object, path, Object);\n  obj[k] = obj[k] || [];\n  if (concat) obj[k] = obj[k].concat(newValue);\n  if (!concat) obj[k].push(newValue);\n}\nfunction getPath(object, path) {\n  const {\n    obj,\n    k\n  } = getLastOfPath(object, path);\n  if (!obj) return undefined;\n  return obj[k];\n}\nfunction getPathWithDefaults(data, defaultData, key) {\n  const value = getPath(data, key);\n  if (value !== undefined) {\n    return value;\n  }\n  return getPath(defaultData, key);\n}\nfunction deepExtend(target, source, overwrite) {\n  for (const prop in source) {\n    if (prop !== '__proto__' && prop !== 'constructor') {\n      if (prop in target) {\n        if (typeof target[prop] === 'string' || target[prop] instanceof String || typeof source[prop] === 'string' || source[prop] instanceof String) {\n          if (overwrite) target[prop] = source[prop];\n        } else {\n          deepExtend(target[prop], source[prop], overwrite);\n        }\n      } else {\n        target[prop] = source[prop];\n      }\n    }\n  }\n  return target;\n}\nfunction regexEscape(str) {\n  return str.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, '\\\\$&');\n}\nvar _entityMap = {\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;',\n  '\"': '&quot;',\n  \"'\": '&#39;',\n  '/': '&#x2F;'\n};\nfunction escape(data) {\n  if (typeof data === 'string') {\n    return data.replace(/[&<>\"'\\/]/g, s => _entityMap[s]);\n  }\n  return data;\n}\nclass RegExpCache {\n  constructor(capacity) {\n    this.capacity = capacity;\n    this.regExpMap = new Map();\n    this.regExpQueue = [];\n  }\n  getRegExp(pattern) {\n    const regExpFromCache = this.regExpMap.get(pattern);\n    if (regExpFromCache !== undefined) {\n      return regExpFromCache;\n    }\n    const regExpNew = new RegExp(pattern);\n    if (this.regExpQueue.length === this.capacity) {\n      this.regExpMap.delete(this.regExpQueue.shift());\n    }\n    this.regExpMap.set(pattern, regExpNew);\n    this.regExpQueue.push(pattern);\n    return regExpNew;\n  }\n}\nconst chars = [' ', ',', '?', '!', ';'];\nconst looksLikeObjectPathRegExpCache = new RegExpCache(20);\nfunction looksLikeObjectPath(key, nsSeparator, keySeparator) {\n  nsSeparator = nsSeparator || '';\n  keySeparator = keySeparator || '';\n  const possibleChars = chars.filter(c => nsSeparator.indexOf(c) < 0 && keySeparator.indexOf(c) < 0);\n  if (possibleChars.length === 0) return true;\n  const r = looksLikeObjectPathRegExpCache.getRegExp(`(${possibleChars.map(c => c === '?' ? '\\\\?' : c).join('|')})`);\n  let matched = !r.test(key);\n  if (!matched) {\n    const ki = key.indexOf(keySeparator);\n    if (ki > 0 && !r.test(key.substring(0, ki))) {\n      matched = true;\n    }\n  }\n  return matched;\n}\nfunction deepFind(obj, path) {\n  let keySeparator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '.';\n  if (!obj) return undefined;\n  if (obj[path]) return obj[path];\n  const tokens = path.split(keySeparator);\n  let current = obj;\n  for (let i = 0; i < tokens.length;) {\n    if (!current || typeof current !== 'object') {\n      return undefined;\n    }\n    let next;\n    let nextPath = '';\n    for (let j = i; j < tokens.length; ++j) {\n      if (j !== i) {\n        nextPath += keySeparator;\n      }\n      nextPath += tokens[j];\n      next = current[nextPath];\n      if (next !== undefined) {\n        if (['string', 'number', 'boolean'].indexOf(typeof next) > -1 && j < tokens.length - 1) {\n          continue;\n        }\n        i += j - i + 1;\n        break;\n      }\n    }\n    current = next;\n  }\n  return current;\n}\nfunction getCleanedCode(code) {\n  if (code && code.indexOf('_') > 0) return code.replace('_', '-');\n  return code;\n}\n\nclass ResourceStore extends EventEmitter {\n  constructor(data) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      ns: ['translation'],\n      defaultNS: 'translation'\n    };\n    super();\n    this.data = data || {};\n    this.options = options;\n    if (this.options.keySeparator === undefined) {\n      this.options.keySeparator = '.';\n    }\n    if (this.options.ignoreJSONStructure === undefined) {\n      this.options.ignoreJSONStructure = true;\n    }\n  }\n  addNamespaces(ns) {\n    if (this.options.ns.indexOf(ns) < 0) {\n      this.options.ns.push(ns);\n    }\n  }\n  removeNamespaces(ns) {\n    const index = this.options.ns.indexOf(ns);\n    if (index > -1) {\n      this.options.ns.splice(index, 1);\n    }\n  }\n  getResource(lng, ns, key) {\n    let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    const keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator;\n    const ignoreJSONStructure = options.ignoreJSONStructure !== undefined ? options.ignoreJSONStructure : this.options.ignoreJSONStructure;\n    let path;\n    if (lng.indexOf('.') > -1) {\n      path = lng.split('.');\n    } else {\n      path = [lng, ns];\n      if (key) {\n        if (Array.isArray(key)) {\n          path.push(...key);\n        } else if (typeof key === 'string' && keySeparator) {\n          path.push(...key.split(keySeparator));\n        } else {\n          path.push(key);\n        }\n      }\n    }\n    const result = getPath(this.data, path);\n    if (!result && !ns && !key && lng.indexOf('.') > -1) {\n      lng = path[0];\n      ns = path[1];\n      key = path.slice(2).join('.');\n    }\n    if (result || !ignoreJSONStructure || typeof key !== 'string') return result;\n    return deepFind(this.data && this.data[lng] && this.data[lng][ns], key, keySeparator);\n  }\n  addResource(lng, ns, key, value) {\n    let options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {\n      silent: false\n    };\n    const keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator;\n    let path = [lng, ns];\n    if (key) path = path.concat(keySeparator ? key.split(keySeparator) : key);\n    if (lng.indexOf('.') > -1) {\n      path = lng.split('.');\n      value = ns;\n      ns = path[1];\n    }\n    this.addNamespaces(ns);\n    setPath(this.data, path, value);\n    if (!options.silent) this.emit('added', lng, ns, key, value);\n  }\n  addResources(lng, ns, resources) {\n    let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {\n      silent: false\n    };\n    for (const m in resources) {\n      if (typeof resources[m] === 'string' || Object.prototype.toString.apply(resources[m]) === '[object Array]') this.addResource(lng, ns, m, resources[m], {\n        silent: true\n      });\n    }\n    if (!options.silent) this.emit('added', lng, ns, resources);\n  }\n  addResourceBundle(lng, ns, resources, deep, overwrite) {\n    let options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {\n      silent: false,\n      skipCopy: false\n    };\n    let path = [lng, ns];\n    if (lng.indexOf('.') > -1) {\n      path = lng.split('.');\n      deep = resources;\n      resources = ns;\n      ns = path[1];\n    }\n    this.addNamespaces(ns);\n    let pack = getPath(this.data, path) || {};\n    if (!options.skipCopy) resources = JSON.parse(JSON.stringify(resources));\n    if (deep) {\n      deepExtend(pack, resources, overwrite);\n    } else {\n      pack = {\n        ...pack,\n        ...resources\n      };\n    }\n    setPath(this.data, path, pack);\n    if (!options.silent) this.emit('added', lng, ns, resources);\n  }\n  removeResourceBundle(lng, ns) {\n    if (this.hasResourceBundle(lng, ns)) {\n      delete this.data[lng][ns];\n    }\n    this.removeNamespaces(ns);\n    this.emit('removed', lng, ns);\n  }\n  hasResourceBundle(lng, ns) {\n    return this.getResource(lng, ns) !== undefined;\n  }\n  getResourceBundle(lng, ns) {\n    if (!ns) ns = this.options.defaultNS;\n    if (this.options.compatibilityAPI === 'v1') return {\n      ...{},\n      ...this.getResource(lng, ns)\n    };\n    return this.getResource(lng, ns);\n  }\n  getDataByLanguage(lng) {\n    return this.data[lng];\n  }\n  hasLanguageSomeTranslations(lng) {\n    const data = this.getDataByLanguage(lng);\n    const n = data && Object.keys(data) || [];\n    return !!n.find(v => data[v] && Object.keys(data[v]).length > 0);\n  }\n  toJSON() {\n    return this.data;\n  }\n}\n\nvar postProcessor = {\n  processors: {},\n  addPostProcessor(module) {\n    this.processors[module.name] = module;\n  },\n  handle(processors, value, key, options, translator) {\n    processors.forEach(processor => {\n      if (this.processors[processor]) value = this.processors[processor].process(value, key, options, translator);\n    });\n    return value;\n  }\n};\n\nconst checkedLoadedFor = {};\nclass Translator extends EventEmitter {\n  constructor(services) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super();\n    copy(['resourceStore', 'languageUtils', 'pluralResolver', 'interpolator', 'backendConnector', 'i18nFormat', 'utils'], services, this);\n    this.options = options;\n    if (this.options.keySeparator === undefined) {\n      this.options.keySeparator = '.';\n    }\n    this.logger = baseLogger.create('translator');\n  }\n  changeLanguage(lng) {\n    if (lng) this.language = lng;\n  }\n  exists(key) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      interpolation: {}\n    };\n    if (key === undefined || key === null) {\n      return false;\n    }\n    const resolved = this.resolve(key, options);\n    return resolved && resolved.res !== undefined;\n  }\n  extractFromKey(key, options) {\n    let nsSeparator = options.nsSeparator !== undefined ? options.nsSeparator : this.options.nsSeparator;\n    if (nsSeparator === undefined) nsSeparator = ':';\n    const keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator;\n    let namespaces = options.ns || this.options.defaultNS || [];\n    const wouldCheckForNsInKey = nsSeparator && key.indexOf(nsSeparator) > -1;\n    const seemsNaturalLanguage = !this.options.userDefinedKeySeparator && !options.keySeparator && !this.options.userDefinedNsSeparator && !options.nsSeparator && !looksLikeObjectPath(key, nsSeparator, keySeparator);\n    if (wouldCheckForNsInKey && !seemsNaturalLanguage) {\n      const m = key.match(this.interpolator.nestingRegexp);\n      if (m && m.length > 0) {\n        return {\n          key,\n          namespaces\n        };\n      }\n      const parts = key.split(nsSeparator);\n      if (nsSeparator !== keySeparator || nsSeparator === keySeparator && this.options.ns.indexOf(parts[0]) > -1) namespaces = parts.shift();\n      key = parts.join(keySeparator);\n    }\n    if (typeof namespaces === 'string') namespaces = [namespaces];\n    return {\n      key,\n      namespaces\n    };\n  }\n  translate(keys, options, lastKey) {\n    if (typeof options !== 'object' && this.options.overloadTranslationOptionHandler) {\n      options = this.options.overloadTranslationOptionHandler(arguments);\n    }\n    if (typeof options === 'object') options = {\n      ...options\n    };\n    if (!options) options = {};\n    if (keys === undefined || keys === null) return '';\n    if (!Array.isArray(keys)) keys = [String(keys)];\n    const returnDetails = options.returnDetails !== undefined ? options.returnDetails : this.options.returnDetails;\n    const keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator;\n    const {\n      key,\n      namespaces\n    } = this.extractFromKey(keys[keys.length - 1], options);\n    const namespace = namespaces[namespaces.length - 1];\n    const lng = options.lng || this.language;\n    const appendNamespaceToCIMode = options.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;\n    if (lng && lng.toLowerCase() === 'cimode') {\n      if (appendNamespaceToCIMode) {\n        const nsSeparator = options.nsSeparator || this.options.nsSeparator;\n        if (returnDetails) {\n          return {\n            res: `${namespace}${nsSeparator}${key}`,\n            usedKey: key,\n            exactUsedKey: key,\n            usedLng: lng,\n            usedNS: namespace,\n            usedParams: this.getUsedParamsDetails(options)\n          };\n        }\n        return `${namespace}${nsSeparator}${key}`;\n      }\n      if (returnDetails) {\n        return {\n          res: key,\n          usedKey: key,\n          exactUsedKey: key,\n          usedLng: lng,\n          usedNS: namespace,\n          usedParams: this.getUsedParamsDetails(options)\n        };\n      }\n      return key;\n    }\n    const resolved = this.resolve(keys, options);\n    let res = resolved && resolved.res;\n    const resUsedKey = resolved && resolved.usedKey || key;\n    const resExactUsedKey = resolved && resolved.exactUsedKey || key;\n    const resType = Object.prototype.toString.apply(res);\n    const noObject = ['[object Number]', '[object Function]', '[object RegExp]'];\n    const joinArrays = options.joinArrays !== undefined ? options.joinArrays : this.options.joinArrays;\n    const handleAsObjectInI18nFormat = !this.i18nFormat || this.i18nFormat.handleAsObject;\n    const handleAsObject = typeof res !== 'string' && typeof res !== 'boolean' && typeof res !== 'number';\n    if (handleAsObjectInI18nFormat && res && handleAsObject && noObject.indexOf(resType) < 0 && !(typeof joinArrays === 'string' && resType === '[object Array]')) {\n      if (!options.returnObjects && !this.options.returnObjects) {\n        if (!this.options.returnedObjectHandler) {\n          this.logger.warn('accessing an object - but returnObjects options is not enabled!');\n        }\n        const r = this.options.returnedObjectHandler ? this.options.returnedObjectHandler(resUsedKey, res, {\n          ...options,\n          ns: namespaces\n        }) : `key '${key} (${this.language})' returned an object instead of string.`;\n        if (returnDetails) {\n          resolved.res = r;\n          resolved.usedParams = this.getUsedParamsDetails(options);\n          return resolved;\n        }\n        return r;\n      }\n      if (keySeparator) {\n        const resTypeIsArray = resType === '[object Array]';\n        const copy = resTypeIsArray ? [] : {};\n        const newKeyToUse = resTypeIsArray ? resExactUsedKey : resUsedKey;\n        for (const m in res) {\n          if (Object.prototype.hasOwnProperty.call(res, m)) {\n            const deepKey = `${newKeyToUse}${keySeparator}${m}`;\n            copy[m] = this.translate(deepKey, {\n              ...options,\n              ...{\n                joinArrays: false,\n                ns: namespaces\n              }\n            });\n            if (copy[m] === deepKey) copy[m] = res[m];\n          }\n        }\n        res = copy;\n      }\n    } else if (handleAsObjectInI18nFormat && typeof joinArrays === 'string' && resType === '[object Array]') {\n      res = res.join(joinArrays);\n      if (res) res = this.extendTranslation(res, keys, options, lastKey);\n    } else {\n      let usedDefault = false;\n      let usedKey = false;\n      const needsPluralHandling = options.count !== undefined && typeof options.count !== 'string';\n      const hasDefaultValue = Translator.hasDefaultValue(options);\n      const defaultValueSuffix = needsPluralHandling ? this.pluralResolver.getSuffix(lng, options.count, options) : '';\n      const defaultValueSuffixOrdinalFallback = options.ordinal && needsPluralHandling ? this.pluralResolver.getSuffix(lng, options.count, {\n        ordinal: false\n      }) : '';\n      const needsZeroSuffixLookup = needsPluralHandling && !options.ordinal && options.count === 0 && this.pluralResolver.shouldUseIntlApi();\n      const defaultValue = needsZeroSuffixLookup && options[`defaultValue${this.options.pluralSeparator}zero`] || options[`defaultValue${defaultValueSuffix}`] || options[`defaultValue${defaultValueSuffixOrdinalFallback}`] || options.defaultValue;\n      if (!this.isValidLookup(res) && hasDefaultValue) {\n        usedDefault = true;\n        res = defaultValue;\n      }\n      if (!this.isValidLookup(res)) {\n        usedKey = true;\n        res = key;\n      }\n      const missingKeyNoValueFallbackToKey = options.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey;\n      const resForMissing = missingKeyNoValueFallbackToKey && usedKey ? undefined : res;\n      const updateMissing = hasDefaultValue && defaultValue !== res && this.options.updateMissing;\n      if (usedKey || usedDefault || updateMissing) {\n        this.logger.log(updateMissing ? 'updateKey' : 'missingKey', lng, namespace, key, updateMissing ? defaultValue : res);\n        if (keySeparator) {\n          const fk = this.resolve(key, {\n            ...options,\n            keySeparator: false\n          });\n          if (fk && fk.res) this.logger.warn('Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.');\n        }\n        let lngs = [];\n        const fallbackLngs = this.languageUtils.getFallbackCodes(this.options.fallbackLng, options.lng || this.language);\n        if (this.options.saveMissingTo === 'fallback' && fallbackLngs && fallbackLngs[0]) {\n          for (let i = 0; i < fallbackLngs.length; i++) {\n            lngs.push(fallbackLngs[i]);\n          }\n        } else if (this.options.saveMissingTo === 'all') {\n          lngs = this.languageUtils.toResolveHierarchy(options.lng || this.language);\n        } else {\n          lngs.push(options.lng || this.language);\n        }\n        const send = (l, k, specificDefaultValue) => {\n          const defaultForMissing = hasDefaultValue && specificDefaultValue !== res ? specificDefaultValue : resForMissing;\n          if (this.options.missingKeyHandler) {\n            this.options.missingKeyHandler(l, namespace, k, defaultForMissing, updateMissing, options);\n          } else if (this.backendConnector && this.backendConnector.saveMissing) {\n            this.backendConnector.saveMissing(l, namespace, k, defaultForMissing, updateMissing, options);\n          }\n          this.emit('missingKey', l, namespace, k, res);\n        };\n        if (this.options.saveMissing) {\n          if (this.options.saveMissingPlurals && needsPluralHandling) {\n            lngs.forEach(language => {\n              const suffixes = this.pluralResolver.getSuffixes(language, options);\n              if (needsZeroSuffixLookup && options[`defaultValue${this.options.pluralSeparator}zero`] && suffixes.indexOf(`${this.options.pluralSeparator}zero`) < 0) {\n                suffixes.push(`${this.options.pluralSeparator}zero`);\n              }\n              suffixes.forEach(suffix => {\n                send([language], key + suffix, options[`defaultValue${suffix}`] || defaultValue);\n              });\n            });\n          } else {\n            send(lngs, key, defaultValue);\n          }\n        }\n      }\n      res = this.extendTranslation(res, keys, options, resolved, lastKey);\n      if (usedKey && res === key && this.options.appendNamespaceToMissingKey) res = `${namespace}:${key}`;\n      if ((usedKey || usedDefault) && this.options.parseMissingKeyHandler) {\n        if (this.options.compatibilityAPI !== 'v1') {\n          res = this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey ? `${namespace}:${key}` : key, usedDefault ? res : undefined);\n        } else {\n          res = this.options.parseMissingKeyHandler(res);\n        }\n      }\n    }\n    if (returnDetails) {\n      resolved.res = res;\n      resolved.usedParams = this.getUsedParamsDetails(options);\n      return resolved;\n    }\n    return res;\n  }\n  extendTranslation(res, key, options, resolved, lastKey) {\n    var _this = this;\n    if (this.i18nFormat && this.i18nFormat.parse) {\n      res = this.i18nFormat.parse(res, {\n        ...this.options.interpolation.defaultVariables,\n        ...options\n      }, options.lng || this.language || resolved.usedLng, resolved.usedNS, resolved.usedKey, {\n        resolved\n      });\n    } else if (!options.skipInterpolation) {\n      if (options.interpolation) this.interpolator.init({\n        ...options,\n        ...{\n          interpolation: {\n            ...this.options.interpolation,\n            ...options.interpolation\n          }\n        }\n      });\n      const skipOnVariables = typeof res === 'string' && (options && options.interpolation && options.interpolation.skipOnVariables !== undefined ? options.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables);\n      let nestBef;\n      if (skipOnVariables) {\n        const nb = res.match(this.interpolator.nestingRegexp);\n        nestBef = nb && nb.length;\n      }\n      let data = options.replace && typeof options.replace !== 'string' ? options.replace : options;\n      if (this.options.interpolation.defaultVariables) data = {\n        ...this.options.interpolation.defaultVariables,\n        ...data\n      };\n      res = this.interpolator.interpolate(res, data, options.lng || this.language, options);\n      if (skipOnVariables) {\n        const na = res.match(this.interpolator.nestingRegexp);\n        const nestAft = na && na.length;\n        if (nestBef < nestAft) options.nest = false;\n      }\n      if (!options.lng && this.options.compatibilityAPI !== 'v1' && resolved && resolved.res) options.lng = resolved.usedLng;\n      if (options.nest !== false) res = this.interpolator.nest(res, function () {\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n        if (lastKey && lastKey[0] === args[0] && !options.context) {\n          _this.logger.warn(`It seems you are nesting recursively key: ${args[0]} in key: ${key[0]}`);\n          return null;\n        }\n        return _this.translate(...args, key);\n      }, options);\n      if (options.interpolation) this.interpolator.reset();\n    }\n    const postProcess = options.postProcess || this.options.postProcess;\n    const postProcessorNames = typeof postProcess === 'string' ? [postProcess] : postProcess;\n    if (res !== undefined && res !== null && postProcessorNames && postProcessorNames.length && options.applyPostProcessor !== false) {\n      res = postProcessor.handle(postProcessorNames, res, key, this.options && this.options.postProcessPassResolved ? {\n        i18nResolved: {\n          ...resolved,\n          usedParams: this.getUsedParamsDetails(options)\n        },\n        ...options\n      } : options, this);\n    }\n    return res;\n  }\n  resolve(keys) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let found;\n    let usedKey;\n    let exactUsedKey;\n    let usedLng;\n    let usedNS;\n    if (typeof keys === 'string') keys = [keys];\n    keys.forEach(k => {\n      if (this.isValidLookup(found)) return;\n      const extracted = this.extractFromKey(k, options);\n      const key = extracted.key;\n      usedKey = key;\n      let namespaces = extracted.namespaces;\n      if (this.options.fallbackNS) namespaces = namespaces.concat(this.options.fallbackNS);\n      const needsPluralHandling = options.count !== undefined && typeof options.count !== 'string';\n      const needsZeroSuffixLookup = needsPluralHandling && !options.ordinal && options.count === 0 && this.pluralResolver.shouldUseIntlApi();\n      const needsContextHandling = options.context !== undefined && (typeof options.context === 'string' || typeof options.context === 'number') && options.context !== '';\n      const codes = options.lngs ? options.lngs : this.languageUtils.toResolveHierarchy(options.lng || this.language, options.fallbackLng);\n      namespaces.forEach(ns => {\n        if (this.isValidLookup(found)) return;\n        usedNS = ns;\n        if (!checkedLoadedFor[`${codes[0]}-${ns}`] && this.utils && this.utils.hasLoadedNamespace && !this.utils.hasLoadedNamespace(usedNS)) {\n          checkedLoadedFor[`${codes[0]}-${ns}`] = true;\n          this.logger.warn(`key \"${usedKey}\" for languages \"${codes.join(', ')}\" won't get resolved as namespace \"${usedNS}\" was not yet loaded`, 'This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!');\n        }\n        codes.forEach(code => {\n          if (this.isValidLookup(found)) return;\n          usedLng = code;\n          const finalKeys = [key];\n          if (this.i18nFormat && this.i18nFormat.addLookupKeys) {\n            this.i18nFormat.addLookupKeys(finalKeys, key, code, ns, options);\n          } else {\n            let pluralSuffix;\n            if (needsPluralHandling) pluralSuffix = this.pluralResolver.getSuffix(code, options.count, options);\n            const zeroSuffix = `${this.options.pluralSeparator}zero`;\n            const ordinalPrefix = `${this.options.pluralSeparator}ordinal${this.options.pluralSeparator}`;\n            if (needsPluralHandling) {\n              finalKeys.push(key + pluralSuffix);\n              if (options.ordinal && pluralSuffix.indexOf(ordinalPrefix) === 0) {\n                finalKeys.push(key + pluralSuffix.replace(ordinalPrefix, this.options.pluralSeparator));\n              }\n              if (needsZeroSuffixLookup) {\n                finalKeys.push(key + zeroSuffix);\n              }\n            }\n            if (needsContextHandling) {\n              const contextKey = `${key}${this.options.contextSeparator}${options.context}`;\n              finalKeys.push(contextKey);\n              if (needsPluralHandling) {\n                finalKeys.push(contextKey + pluralSuffix);\n                if (options.ordinal && pluralSuffix.indexOf(ordinalPrefix) === 0) {\n                  finalKeys.push(contextKey + pluralSuffix.replace(ordinalPrefix, this.options.pluralSeparator));\n                }\n                if (needsZeroSuffixLookup) {\n                  finalKeys.push(contextKey + zeroSuffix);\n                }\n              }\n            }\n          }\n          let possibleKey;\n          while (possibleKey = finalKeys.pop()) {\n            if (!this.isValidLookup(found)) {\n              exactUsedKey = possibleKey;\n              found = this.getResource(code, ns, possibleKey, options);\n            }\n          }\n        });\n      });\n    });\n    return {\n      res: found,\n      usedKey,\n      exactUsedKey,\n      usedLng,\n      usedNS\n    };\n  }\n  isValidLookup(res) {\n    return res !== undefined && !(!this.options.returnNull && res === null) && !(!this.options.returnEmptyString && res === '');\n  }\n  getResource(code, ns, key) {\n    let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    if (this.i18nFormat && this.i18nFormat.getResource) return this.i18nFormat.getResource(code, ns, key, options);\n    return this.resourceStore.getResource(code, ns, key, options);\n  }\n  getUsedParamsDetails() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const optionsKeys = ['defaultValue', 'ordinal', 'context', 'replace', 'lng', 'lngs', 'fallbackLng', 'ns', 'keySeparator', 'nsSeparator', 'returnObjects', 'returnDetails', 'joinArrays', 'postProcess', 'interpolation'];\n    const useOptionsReplaceForData = options.replace && typeof options.replace !== 'string';\n    let data = useOptionsReplaceForData ? options.replace : options;\n    if (useOptionsReplaceForData && typeof options.count !== 'undefined') {\n      data.count = options.count;\n    }\n    if (this.options.interpolation.defaultVariables) {\n      data = {\n        ...this.options.interpolation.defaultVariables,\n        ...data\n      };\n    }\n    if (!useOptionsReplaceForData) {\n      data = {\n        ...data\n      };\n      for (const key of optionsKeys) {\n        delete data[key];\n      }\n    }\n    return data;\n  }\n  static hasDefaultValue(options) {\n    const prefix = 'defaultValue';\n    for (const option in options) {\n      if (Object.prototype.hasOwnProperty.call(options, option) && prefix === option.substring(0, prefix.length) && undefined !== options[option]) {\n        return true;\n      }\n    }\n    return false;\n  }\n}\n\nfunction capitalize(string) {\n  return string.charAt(0).toUpperCase() + string.slice(1);\n}\nclass LanguageUtil {\n  constructor(options) {\n    this.options = options;\n    this.supportedLngs = this.options.supportedLngs || false;\n    this.logger = baseLogger.create('languageUtils');\n  }\n  getScriptPartFromCode(code) {\n    code = getCleanedCode(code);\n    if (!code || code.indexOf('-') < 0) return null;\n    const p = code.split('-');\n    if (p.length === 2) return null;\n    p.pop();\n    if (p[p.length - 1].toLowerCase() === 'x') return null;\n    return this.formatLanguageCode(p.join('-'));\n  }\n  getLanguagePartFromCode(code) {\n    code = getCleanedCode(code);\n    if (!code || code.indexOf('-') < 0) return code;\n    const p = code.split('-');\n    return this.formatLanguageCode(p[0]);\n  }\n  formatLanguageCode(code) {\n    if (typeof code === 'string' && code.indexOf('-') > -1) {\n      const specialCases = ['hans', 'hant', 'latn', 'cyrl', 'cans', 'mong', 'arab'];\n      let p = code.split('-');\n      if (this.options.lowerCaseLng) {\n        p = p.map(part => part.toLowerCase());\n      } else if (p.length === 2) {\n        p[0] = p[0].toLowerCase();\n        p[1] = p[1].toUpperCase();\n        if (specialCases.indexOf(p[1].toLowerCase()) > -1) p[1] = capitalize(p[1].toLowerCase());\n      } else if (p.length === 3) {\n        p[0] = p[0].toLowerCase();\n        if (p[1].length === 2) p[1] = p[1].toUpperCase();\n        if (p[0] !== 'sgn' && p[2].length === 2) p[2] = p[2].toUpperCase();\n        if (specialCases.indexOf(p[1].toLowerCase()) > -1) p[1] = capitalize(p[1].toLowerCase());\n        if (specialCases.indexOf(p[2].toLowerCase()) > -1) p[2] = capitalize(p[2].toLowerCase());\n      }\n      return p.join('-');\n    }\n    return this.options.cleanCode || this.options.lowerCaseLng ? code.toLowerCase() : code;\n  }\n  isSupportedCode(code) {\n    if (this.options.load === 'languageOnly' || this.options.nonExplicitSupportedLngs) {\n      code = this.getLanguagePartFromCode(code);\n    }\n    return !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(code) > -1;\n  }\n  getBestMatchFromCodes(codes) {\n    if (!codes) return null;\n    let found;\n    codes.forEach(code => {\n      if (found) return;\n      const cleanedLng = this.formatLanguageCode(code);\n      if (!this.options.supportedLngs || this.isSupportedCode(cleanedLng)) found = cleanedLng;\n    });\n    if (!found && this.options.supportedLngs) {\n      codes.forEach(code => {\n        if (found) return;\n        const lngOnly = this.getLanguagePartFromCode(code);\n        if (this.isSupportedCode(lngOnly)) return found = lngOnly;\n        found = this.options.supportedLngs.find(supportedLng => {\n          if (supportedLng === lngOnly) return supportedLng;\n          if (supportedLng.indexOf('-') < 0 && lngOnly.indexOf('-') < 0) return;\n          if (supportedLng.indexOf('-') > 0 && lngOnly.indexOf('-') < 0 && supportedLng.substring(0, supportedLng.indexOf('-')) === lngOnly) return supportedLng;\n          if (supportedLng.indexOf(lngOnly) === 0 && lngOnly.length > 1) return supportedLng;\n        });\n      });\n    }\n    if (!found) found = this.getFallbackCodes(this.options.fallbackLng)[0];\n    return found;\n  }\n  getFallbackCodes(fallbacks, code) {\n    if (!fallbacks) return [];\n    if (typeof fallbacks === 'function') fallbacks = fallbacks(code);\n    if (typeof fallbacks === 'string') fallbacks = [fallbacks];\n    if (Object.prototype.toString.apply(fallbacks) === '[object Array]') return fallbacks;\n    if (!code) return fallbacks.default || [];\n    let found = fallbacks[code];\n    if (!found) found = fallbacks[this.getScriptPartFromCode(code)];\n    if (!found) found = fallbacks[this.formatLanguageCode(code)];\n    if (!found) found = fallbacks[this.getLanguagePartFromCode(code)];\n    if (!found) found = fallbacks.default;\n    return found || [];\n  }\n  toResolveHierarchy(code, fallbackCode) {\n    const fallbackCodes = this.getFallbackCodes(fallbackCode || this.options.fallbackLng || [], code);\n    const codes = [];\n    const addCode = c => {\n      if (!c) return;\n      if (this.isSupportedCode(c)) {\n        codes.push(c);\n      } else {\n        this.logger.warn(`rejecting language code not found in supportedLngs: ${c}`);\n      }\n    };\n    if (typeof code === 'string' && (code.indexOf('-') > -1 || code.indexOf('_') > -1)) {\n      if (this.options.load !== 'languageOnly') addCode(this.formatLanguageCode(code));\n      if (this.options.load !== 'languageOnly' && this.options.load !== 'currentOnly') addCode(this.getScriptPartFromCode(code));\n      if (this.options.load !== 'currentOnly') addCode(this.getLanguagePartFromCode(code));\n    } else if (typeof code === 'string') {\n      addCode(this.formatLanguageCode(code));\n    }\n    fallbackCodes.forEach(fc => {\n      if (codes.indexOf(fc) < 0) addCode(this.formatLanguageCode(fc));\n    });\n    return codes;\n  }\n}\n\nlet sets = [{\n  lngs: ['ach', 'ak', 'am', 'arn', 'br', 'fil', 'gun', 'ln', 'mfe', 'mg', 'mi', 'oc', 'pt', 'pt-BR', 'tg', 'tl', 'ti', 'tr', 'uz', 'wa'],\n  nr: [1, 2],\n  fc: 1\n}, {\n  lngs: ['af', 'an', 'ast', 'az', 'bg', 'bn', 'ca', 'da', 'de', 'dev', 'el', 'en', 'eo', 'es', 'et', 'eu', 'fi', 'fo', 'fur', 'fy', 'gl', 'gu', 'ha', 'hi', 'hu', 'hy', 'ia', 'it', 'kk', 'kn', 'ku', 'lb', 'mai', 'ml', 'mn', 'mr', 'nah', 'nap', 'nb', 'ne', 'nl', 'nn', 'no', 'nso', 'pa', 'pap', 'pms', 'ps', 'pt-PT', 'rm', 'sco', 'se', 'si', 'so', 'son', 'sq', 'sv', 'sw', 'ta', 'te', 'tk', 'ur', 'yo'],\n  nr: [1, 2],\n  fc: 2\n}, {\n  lngs: ['ay', 'bo', 'cgg', 'fa', 'ht', 'id', 'ja', 'jbo', 'ka', 'km', 'ko', 'ky', 'lo', 'ms', 'sah', 'su', 'th', 'tt', 'ug', 'vi', 'wo', 'zh'],\n  nr: [1],\n  fc: 3\n}, {\n  lngs: ['be', 'bs', 'cnr', 'dz', 'hr', 'ru', 'sr', 'uk'],\n  nr: [1, 2, 5],\n  fc: 4\n}, {\n  lngs: ['ar'],\n  nr: [0, 1, 2, 3, 11, 100],\n  fc: 5\n}, {\n  lngs: ['cs', 'sk'],\n  nr: [1, 2, 5],\n  fc: 6\n}, {\n  lngs: ['csb', 'pl'],\n  nr: [1, 2, 5],\n  fc: 7\n}, {\n  lngs: ['cy'],\n  nr: [1, 2, 3, 8],\n  fc: 8\n}, {\n  lngs: ['fr'],\n  nr: [1, 2],\n  fc: 9\n}, {\n  lngs: ['ga'],\n  nr: [1, 2, 3, 7, 11],\n  fc: 10\n}, {\n  lngs: ['gd'],\n  nr: [1, 2, 3, 20],\n  fc: 11\n}, {\n  lngs: ['is'],\n  nr: [1, 2],\n  fc: 12\n}, {\n  lngs: ['jv'],\n  nr: [0, 1],\n  fc: 13\n}, {\n  lngs: ['kw'],\n  nr: [1, 2, 3, 4],\n  fc: 14\n}, {\n  lngs: ['lt'],\n  nr: [1, 2, 10],\n  fc: 15\n}, {\n  lngs: ['lv'],\n  nr: [1, 2, 0],\n  fc: 16\n}, {\n  lngs: ['mk'],\n  nr: [1, 2],\n  fc: 17\n}, {\n  lngs: ['mnk'],\n  nr: [0, 1, 2],\n  fc: 18\n}, {\n  lngs: ['mt'],\n  nr: [1, 2, 11, 20],\n  fc: 19\n}, {\n  lngs: ['or'],\n  nr: [2, 1],\n  fc: 2\n}, {\n  lngs: ['ro'],\n  nr: [1, 2, 20],\n  fc: 20\n}, {\n  lngs: ['sl'],\n  nr: [5, 1, 2, 3],\n  fc: 21\n}, {\n  lngs: ['he', 'iw'],\n  nr: [1, 2, 20, 21],\n  fc: 22\n}];\nlet _rulesPluralsTypes = {\n  1: function (n) {\n    return Number(n > 1);\n  },\n  2: function (n) {\n    return Number(n != 1);\n  },\n  3: function (n) {\n    return 0;\n  },\n  4: function (n) {\n    return Number(n % 10 == 1 && n % 100 != 11 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);\n  },\n  5: function (n) {\n    return Number(n == 0 ? 0 : n == 1 ? 1 : n == 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5);\n  },\n  6: function (n) {\n    return Number(n == 1 ? 0 : n >= 2 && n <= 4 ? 1 : 2);\n  },\n  7: function (n) {\n    return Number(n == 1 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);\n  },\n  8: function (n) {\n    return Number(n == 1 ? 0 : n == 2 ? 1 : n != 8 && n != 11 ? 2 : 3);\n  },\n  9: function (n) {\n    return Number(n >= 2);\n  },\n  10: function (n) {\n    return Number(n == 1 ? 0 : n == 2 ? 1 : n < 7 ? 2 : n < 11 ? 3 : 4);\n  },\n  11: function (n) {\n    return Number(n == 1 || n == 11 ? 0 : n == 2 || n == 12 ? 1 : n > 2 && n < 20 ? 2 : 3);\n  },\n  12: function (n) {\n    return Number(n % 10 != 1 || n % 100 == 11);\n  },\n  13: function (n) {\n    return Number(n !== 0);\n  },\n  14: function (n) {\n    return Number(n == 1 ? 0 : n == 2 ? 1 : n == 3 ? 2 : 3);\n  },\n  15: function (n) {\n    return Number(n % 10 == 1 && n % 100 != 11 ? 0 : n % 10 >= 2 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);\n  },\n  16: function (n) {\n    return Number(n % 10 == 1 && n % 100 != 11 ? 0 : n !== 0 ? 1 : 2);\n  },\n  17: function (n) {\n    return Number(n == 1 || n % 10 == 1 && n % 100 != 11 ? 0 : 1);\n  },\n  18: function (n) {\n    return Number(n == 0 ? 0 : n == 1 ? 1 : 2);\n  },\n  19: function (n) {\n    return Number(n == 1 ? 0 : n == 0 || n % 100 > 1 && n % 100 < 11 ? 1 : n % 100 > 10 && n % 100 < 20 ? 2 : 3);\n  },\n  20: function (n) {\n    return Number(n == 1 ? 0 : n == 0 || n % 100 > 0 && n % 100 < 20 ? 1 : 2);\n  },\n  21: function (n) {\n    return Number(n % 100 == 1 ? 1 : n % 100 == 2 ? 2 : n % 100 == 3 || n % 100 == 4 ? 3 : 0);\n  },\n  22: function (n) {\n    return Number(n == 1 ? 0 : n == 2 ? 1 : (n < 0 || n > 10) && n % 10 == 0 ? 2 : 3);\n  }\n};\nconst nonIntlVersions = ['v1', 'v2', 'v3'];\nconst intlVersions = ['v4'];\nconst suffixesOrder = {\n  zero: 0,\n  one: 1,\n  two: 2,\n  few: 3,\n  many: 4,\n  other: 5\n};\nfunction createRules() {\n  const rules = {};\n  sets.forEach(set => {\n    set.lngs.forEach(l => {\n      rules[l] = {\n        numbers: set.nr,\n        plurals: _rulesPluralsTypes[set.fc]\n      };\n    });\n  });\n  return rules;\n}\nclass PluralResolver {\n  constructor(languageUtils) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.languageUtils = languageUtils;\n    this.options = options;\n    this.logger = baseLogger.create('pluralResolver');\n    if ((!this.options.compatibilityJSON || intlVersions.includes(this.options.compatibilityJSON)) && (typeof Intl === 'undefined' || !Intl.PluralRules)) {\n      this.options.compatibilityJSON = 'v3';\n      this.logger.error('Your environment seems not to be Intl API compatible, use an Intl.PluralRules polyfill. Will fallback to the compatibilityJSON v3 format handling.');\n    }\n    this.rules = createRules();\n  }\n  addRule(lng, obj) {\n    this.rules[lng] = obj;\n  }\n  getRule(code) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (this.shouldUseIntlApi()) {\n      try {\n        return new Intl.PluralRules(getCleanedCode(code === 'dev' ? 'en' : code), {\n          type: options.ordinal ? 'ordinal' : 'cardinal'\n        });\n      } catch (err) {\n        return;\n      }\n    }\n    return this.rules[code] || this.rules[this.languageUtils.getLanguagePartFromCode(code)];\n  }\n  needsPlural(code) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const rule = this.getRule(code, options);\n    if (this.shouldUseIntlApi()) {\n      return rule && rule.resolvedOptions().pluralCategories.length > 1;\n    }\n    return rule && rule.numbers.length > 1;\n  }\n  getPluralFormsOfKey(code, key) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return this.getSuffixes(code, options).map(suffix => `${key}${suffix}`);\n  }\n  getSuffixes(code) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const rule = this.getRule(code, options);\n    if (!rule) {\n      return [];\n    }\n    if (this.shouldUseIntlApi()) {\n      return rule.resolvedOptions().pluralCategories.sort((pluralCategory1, pluralCategory2) => suffixesOrder[pluralCategory1] - suffixesOrder[pluralCategory2]).map(pluralCategory => `${this.options.prepend}${options.ordinal ? `ordinal${this.options.prepend}` : ''}${pluralCategory}`);\n    }\n    return rule.numbers.map(number => this.getSuffix(code, number, options));\n  }\n  getSuffix(code, count) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    const rule = this.getRule(code, options);\n    if (rule) {\n      if (this.shouldUseIntlApi()) {\n        return `${this.options.prepend}${options.ordinal ? `ordinal${this.options.prepend}` : ''}${rule.select(count)}`;\n      }\n      return this.getSuffixRetroCompatible(rule, count);\n    }\n    this.logger.warn(`no plural rule found for: ${code}`);\n    return '';\n  }\n  getSuffixRetroCompatible(rule, count) {\n    const idx = rule.noAbs ? rule.plurals(count) : rule.plurals(Math.abs(count));\n    let suffix = rule.numbers[idx];\n    if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {\n      if (suffix === 2) {\n        suffix = 'plural';\n      } else if (suffix === 1) {\n        suffix = '';\n      }\n    }\n    const returnSuffix = () => this.options.prepend && suffix.toString() ? this.options.prepend + suffix.toString() : suffix.toString();\n    if (this.options.compatibilityJSON === 'v1') {\n      if (suffix === 1) return '';\n      if (typeof suffix === 'number') return `_plural_${suffix.toString()}`;\n      return returnSuffix();\n    } else if (this.options.compatibilityJSON === 'v2') {\n      return returnSuffix();\n    } else if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {\n      return returnSuffix();\n    }\n    return this.options.prepend && idx.toString() ? this.options.prepend + idx.toString() : idx.toString();\n  }\n  shouldUseIntlApi() {\n    return !nonIntlVersions.includes(this.options.compatibilityJSON);\n  }\n}\n\nfunction deepFindWithDefaults(data, defaultData, key) {\n  let keySeparator = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '.';\n  let ignoreJSONStructure = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n  let path = getPathWithDefaults(data, defaultData, key);\n  if (!path && ignoreJSONStructure && typeof key === 'string') {\n    path = deepFind(data, key, keySeparator);\n    if (path === undefined) path = deepFind(defaultData, key, keySeparator);\n  }\n  return path;\n}\nclass Interpolator {\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.logger = baseLogger.create('interpolator');\n    this.options = options;\n    this.format = options.interpolation && options.interpolation.format || (value => value);\n    this.init(options);\n  }\n  init() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (!options.interpolation) options.interpolation = {\n      escapeValue: true\n    };\n    const iOpts = options.interpolation;\n    this.escape = iOpts.escape !== undefined ? iOpts.escape : escape;\n    this.escapeValue = iOpts.escapeValue !== undefined ? iOpts.escapeValue : true;\n    this.useRawValueToEscape = iOpts.useRawValueToEscape !== undefined ? iOpts.useRawValueToEscape : false;\n    this.prefix = iOpts.prefix ? regexEscape(iOpts.prefix) : iOpts.prefixEscaped || '{{';\n    this.suffix = iOpts.suffix ? regexEscape(iOpts.suffix) : iOpts.suffixEscaped || '}}';\n    this.formatSeparator = iOpts.formatSeparator ? iOpts.formatSeparator : iOpts.formatSeparator || ',';\n    this.unescapePrefix = iOpts.unescapeSuffix ? '' : iOpts.unescapePrefix || '-';\n    this.unescapeSuffix = this.unescapePrefix ? '' : iOpts.unescapeSuffix || '';\n    this.nestingPrefix = iOpts.nestingPrefix ? regexEscape(iOpts.nestingPrefix) : iOpts.nestingPrefixEscaped || regexEscape('$t(');\n    this.nestingSuffix = iOpts.nestingSuffix ? regexEscape(iOpts.nestingSuffix) : iOpts.nestingSuffixEscaped || regexEscape(')');\n    this.nestingOptionsSeparator = iOpts.nestingOptionsSeparator ? iOpts.nestingOptionsSeparator : iOpts.nestingOptionsSeparator || ',';\n    this.maxReplaces = iOpts.maxReplaces ? iOpts.maxReplaces : 1000;\n    this.alwaysFormat = iOpts.alwaysFormat !== undefined ? iOpts.alwaysFormat : false;\n    this.resetRegExp();\n  }\n  reset() {\n    if (this.options) this.init(this.options);\n  }\n  resetRegExp() {\n    const getOrResetRegExp = (existingRegExp, pattern) => {\n      if (existingRegExp && existingRegExp.source === pattern) {\n        existingRegExp.lastIndex = 0;\n        return existingRegExp;\n      }\n      return new RegExp(pattern, 'g');\n    };\n    this.regexp = getOrResetRegExp(this.regexp, `${this.prefix}(.+?)${this.suffix}`);\n    this.regexpUnescape = getOrResetRegExp(this.regexpUnescape, `${this.prefix}${this.unescapePrefix}(.+?)${this.unescapeSuffix}${this.suffix}`);\n    this.nestingRegexp = getOrResetRegExp(this.nestingRegexp, `${this.nestingPrefix}(.+?)${this.nestingSuffix}`);\n  }\n  interpolate(str, data, lng, options) {\n    let match;\n    let value;\n    let replaces;\n    const defaultData = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};\n    function regexSafe(val) {\n      return val.replace(/\\$/g, '$$$$');\n    }\n    const handleFormat = key => {\n      if (key.indexOf(this.formatSeparator) < 0) {\n        const path = deepFindWithDefaults(data, defaultData, key, this.options.keySeparator, this.options.ignoreJSONStructure);\n        return this.alwaysFormat ? this.format(path, undefined, lng, {\n          ...options,\n          ...data,\n          interpolationkey: key\n        }) : path;\n      }\n      const p = key.split(this.formatSeparator);\n      const k = p.shift().trim();\n      const f = p.join(this.formatSeparator).trim();\n      return this.format(deepFindWithDefaults(data, defaultData, k, this.options.keySeparator, this.options.ignoreJSONStructure), f, lng, {\n        ...options,\n        ...data,\n        interpolationkey: k\n      });\n    };\n    this.resetRegExp();\n    const missingInterpolationHandler = options && options.missingInterpolationHandler || this.options.missingInterpolationHandler;\n    const skipOnVariables = options && options.interpolation && options.interpolation.skipOnVariables !== undefined ? options.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables;\n    const todos = [{\n      regex: this.regexpUnescape,\n      safeValue: val => regexSafe(val)\n    }, {\n      regex: this.regexp,\n      safeValue: val => this.escapeValue ? regexSafe(this.escape(val)) : regexSafe(val)\n    }];\n    todos.forEach(todo => {\n      replaces = 0;\n      while (match = todo.regex.exec(str)) {\n        const matchedVar = match[1].trim();\n        value = handleFormat(matchedVar);\n        if (value === undefined) {\n          if (typeof missingInterpolationHandler === 'function') {\n            const temp = missingInterpolationHandler(str, match, options);\n            value = typeof temp === 'string' ? temp : '';\n          } else if (options && Object.prototype.hasOwnProperty.call(options, matchedVar)) {\n            value = '';\n          } else if (skipOnVariables) {\n            value = match[0];\n            continue;\n          } else {\n            this.logger.warn(`missed to pass in variable ${matchedVar} for interpolating ${str}`);\n            value = '';\n          }\n        } else if (typeof value !== 'string' && !this.useRawValueToEscape) {\n          value = makeString(value);\n        }\n        const safeValue = todo.safeValue(value);\n        str = str.replace(match[0], safeValue);\n        if (skipOnVariables) {\n          todo.regex.lastIndex += value.length;\n          todo.regex.lastIndex -= match[0].length;\n        } else {\n          todo.regex.lastIndex = 0;\n        }\n        replaces++;\n        if (replaces >= this.maxReplaces) {\n          break;\n        }\n      }\n    });\n    return str;\n  }\n  nest(str, fc) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let match;\n    let value;\n    let clonedOptions;\n    function handleHasOptions(key, inheritedOptions) {\n      const sep = this.nestingOptionsSeparator;\n      if (key.indexOf(sep) < 0) return key;\n      const c = key.split(new RegExp(`${sep}[ ]*{`));\n      let optionsString = `{${c[1]}`;\n      key = c[0];\n      optionsString = this.interpolate(optionsString, clonedOptions);\n      const matchedSingleQuotes = optionsString.match(/'/g);\n      const matchedDoubleQuotes = optionsString.match(/\"/g);\n      if (matchedSingleQuotes && matchedSingleQuotes.length % 2 === 0 && !matchedDoubleQuotes || matchedDoubleQuotes.length % 2 !== 0) {\n        optionsString = optionsString.replace(/'/g, '\"');\n      }\n      try {\n        clonedOptions = JSON.parse(optionsString);\n        if (inheritedOptions) clonedOptions = {\n          ...inheritedOptions,\n          ...clonedOptions\n        };\n      } catch (e) {\n        this.logger.warn(`failed parsing options string in nesting for key ${key}`, e);\n        return `${key}${sep}${optionsString}`;\n      }\n      delete clonedOptions.defaultValue;\n      return key;\n    }\n    while (match = this.nestingRegexp.exec(str)) {\n      let formatters = [];\n      clonedOptions = {\n        ...options\n      };\n      clonedOptions = clonedOptions.replace && typeof clonedOptions.replace !== 'string' ? clonedOptions.replace : clonedOptions;\n      clonedOptions.applyPostProcessor = false;\n      delete clonedOptions.defaultValue;\n      let doReduce = false;\n      if (match[0].indexOf(this.formatSeparator) !== -1 && !/{.*}/.test(match[1])) {\n        const r = match[1].split(this.formatSeparator).map(elem => elem.trim());\n        match[1] = r.shift();\n        formatters = r;\n        doReduce = true;\n      }\n      value = fc(handleHasOptions.call(this, match[1].trim(), clonedOptions), clonedOptions);\n      if (value && match[0] === str && typeof value !== 'string') return value;\n      if (typeof value !== 'string') value = makeString(value);\n      if (!value) {\n        this.logger.warn(`missed to resolve ${match[1]} for nesting ${str}`);\n        value = '';\n      }\n      if (doReduce) {\n        value = formatters.reduce((v, f) => this.format(v, f, options.lng, {\n          ...options,\n          interpolationkey: match[1].trim()\n        }), value.trim());\n      }\n      str = str.replace(match[0], value);\n      this.regexp.lastIndex = 0;\n    }\n    return str;\n  }\n}\n\nfunction parseFormatStr(formatStr) {\n  let formatName = formatStr.toLowerCase().trim();\n  const formatOptions = {};\n  if (formatStr.indexOf('(') > -1) {\n    const p = formatStr.split('(');\n    formatName = p[0].toLowerCase().trim();\n    const optStr = p[1].substring(0, p[1].length - 1);\n    if (formatName === 'currency' && optStr.indexOf(':') < 0) {\n      if (!formatOptions.currency) formatOptions.currency = optStr.trim();\n    } else if (formatName === 'relativetime' && optStr.indexOf(':') < 0) {\n      if (!formatOptions.range) formatOptions.range = optStr.trim();\n    } else {\n      const opts = optStr.split(';');\n      opts.forEach(opt => {\n        if (!opt) return;\n        const [key, ...rest] = opt.split(':');\n        const val = rest.join(':').trim().replace(/^'+|'+$/g, '');\n        if (!formatOptions[key.trim()]) formatOptions[key.trim()] = val;\n        if (val === 'false') formatOptions[key.trim()] = false;\n        if (val === 'true') formatOptions[key.trim()] = true;\n        if (!isNaN(val)) formatOptions[key.trim()] = parseInt(val, 10);\n      });\n    }\n  }\n  return {\n    formatName,\n    formatOptions\n  };\n}\nfunction createCachedFormatter(fn) {\n  const cache = {};\n  return function invokeFormatter(val, lng, options) {\n    const key = lng + JSON.stringify(options);\n    let formatter = cache[key];\n    if (!formatter) {\n      formatter = fn(getCleanedCode(lng), options);\n      cache[key] = formatter;\n    }\n    return formatter(val);\n  };\n}\nclass Formatter {\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.logger = baseLogger.create('formatter');\n    this.options = options;\n    this.formats = {\n      number: createCachedFormatter((lng, opt) => {\n        const formatter = new Intl.NumberFormat(lng, {\n          ...opt\n        });\n        return val => formatter.format(val);\n      }),\n      currency: createCachedFormatter((lng, opt) => {\n        const formatter = new Intl.NumberFormat(lng, {\n          ...opt,\n          style: 'currency'\n        });\n        return val => formatter.format(val);\n      }),\n      datetime: createCachedFormatter((lng, opt) => {\n        const formatter = new Intl.DateTimeFormat(lng, {\n          ...opt\n        });\n        return val => formatter.format(val);\n      }),\n      relativetime: createCachedFormatter((lng, opt) => {\n        const formatter = new Intl.RelativeTimeFormat(lng, {\n          ...opt\n        });\n        return val => formatter.format(val, opt.range || 'day');\n      }),\n      list: createCachedFormatter((lng, opt) => {\n        const formatter = new Intl.ListFormat(lng, {\n          ...opt\n        });\n        return val => formatter.format(val);\n      })\n    };\n    this.init(options);\n  }\n  init(services) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      interpolation: {}\n    };\n    const iOpts = options.interpolation;\n    this.formatSeparator = iOpts.formatSeparator ? iOpts.formatSeparator : iOpts.formatSeparator || ',';\n  }\n  add(name, fc) {\n    this.formats[name.toLowerCase().trim()] = fc;\n  }\n  addCached(name, fc) {\n    this.formats[name.toLowerCase().trim()] = createCachedFormatter(fc);\n  }\n  format(value, format, lng) {\n    let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    const formats = format.split(this.formatSeparator);\n    const result = formats.reduce((mem, f) => {\n      const {\n        formatName,\n        formatOptions\n      } = parseFormatStr(f);\n      if (this.formats[formatName]) {\n        let formatted = mem;\n        try {\n          const valOptions = options && options.formatParams && options.formatParams[options.interpolationkey] || {};\n          const l = valOptions.locale || valOptions.lng || options.locale || options.lng || lng;\n          formatted = this.formats[formatName](mem, l, {\n            ...formatOptions,\n            ...options,\n            ...valOptions\n          });\n        } catch (error) {\n          this.logger.warn(error);\n        }\n        return formatted;\n      } else {\n        this.logger.warn(`there was no format function for ${formatName}`);\n      }\n      return mem;\n    }, value);\n    return result;\n  }\n}\n\nfunction removePending(q, name) {\n  if (q.pending[name] !== undefined) {\n    delete q.pending[name];\n    q.pendingCount--;\n  }\n}\nclass Connector extends EventEmitter {\n  constructor(backend, store, services) {\n    let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    super();\n    this.backend = backend;\n    this.store = store;\n    this.services = services;\n    this.languageUtils = services.languageUtils;\n    this.options = options;\n    this.logger = baseLogger.create('backendConnector');\n    this.waitingReads = [];\n    this.maxParallelReads = options.maxParallelReads || 10;\n    this.readingCalls = 0;\n    this.maxRetries = options.maxRetries >= 0 ? options.maxRetries : 5;\n    this.retryTimeout = options.retryTimeout >= 1 ? options.retryTimeout : 350;\n    this.state = {};\n    this.queue = [];\n    if (this.backend && this.backend.init) {\n      this.backend.init(services, options.backend, options);\n    }\n  }\n  queueLoad(languages, namespaces, options, callback) {\n    const toLoad = {};\n    const pending = {};\n    const toLoadLanguages = {};\n    const toLoadNamespaces = {};\n    languages.forEach(lng => {\n      let hasAllNamespaces = true;\n      namespaces.forEach(ns => {\n        const name = `${lng}|${ns}`;\n        if (!options.reload && this.store.hasResourceBundle(lng, ns)) {\n          this.state[name] = 2;\n        } else if (this.state[name] < 0) ; else if (this.state[name] === 1) {\n          if (pending[name] === undefined) pending[name] = true;\n        } else {\n          this.state[name] = 1;\n          hasAllNamespaces = false;\n          if (pending[name] === undefined) pending[name] = true;\n          if (toLoad[name] === undefined) toLoad[name] = true;\n          if (toLoadNamespaces[ns] === undefined) toLoadNamespaces[ns] = true;\n        }\n      });\n      if (!hasAllNamespaces) toLoadLanguages[lng] = true;\n    });\n    if (Object.keys(toLoad).length || Object.keys(pending).length) {\n      this.queue.push({\n        pending,\n        pendingCount: Object.keys(pending).length,\n        loaded: {},\n        errors: [],\n        callback\n      });\n    }\n    return {\n      toLoad: Object.keys(toLoad),\n      pending: Object.keys(pending),\n      toLoadLanguages: Object.keys(toLoadLanguages),\n      toLoadNamespaces: Object.keys(toLoadNamespaces)\n    };\n  }\n  loaded(name, err, data) {\n    const s = name.split('|');\n    const lng = s[0];\n    const ns = s[1];\n    if (err) this.emit('failedLoading', lng, ns, err);\n    if (data) {\n      this.store.addResourceBundle(lng, ns, data, undefined, undefined, {\n        skipCopy: true\n      });\n    }\n    this.state[name] = err ? -1 : 2;\n    const loaded = {};\n    this.queue.forEach(q => {\n      pushPath(q.loaded, [lng], ns);\n      removePending(q, name);\n      if (err) q.errors.push(err);\n      if (q.pendingCount === 0 && !q.done) {\n        Object.keys(q.loaded).forEach(l => {\n          if (!loaded[l]) loaded[l] = {};\n          const loadedKeys = q.loaded[l];\n          if (loadedKeys.length) {\n            loadedKeys.forEach(n => {\n              if (loaded[l][n] === undefined) loaded[l][n] = true;\n            });\n          }\n        });\n        q.done = true;\n        if (q.errors.length) {\n          q.callback(q.errors);\n        } else {\n          q.callback();\n        }\n      }\n    });\n    this.emit('loaded', loaded);\n    this.queue = this.queue.filter(q => !q.done);\n  }\n  read(lng, ns, fcName) {\n    let tried = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    let wait = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : this.retryTimeout;\n    let callback = arguments.length > 5 ? arguments[5] : undefined;\n    if (!lng.length) return callback(null, {});\n    if (this.readingCalls >= this.maxParallelReads) {\n      this.waitingReads.push({\n        lng,\n        ns,\n        fcName,\n        tried,\n        wait,\n        callback\n      });\n      return;\n    }\n    this.readingCalls++;\n    const resolver = (err, data) => {\n      this.readingCalls--;\n      if (this.waitingReads.length > 0) {\n        const next = this.waitingReads.shift();\n        this.read(next.lng, next.ns, next.fcName, next.tried, next.wait, next.callback);\n      }\n      if (err && data && tried < this.maxRetries) {\n        setTimeout(() => {\n          this.read.call(this, lng, ns, fcName, tried + 1, wait * 2, callback);\n        }, wait);\n        return;\n      }\n      callback(err, data);\n    };\n    const fc = this.backend[fcName].bind(this.backend);\n    if (fc.length === 2) {\n      try {\n        const r = fc(lng, ns);\n        if (r && typeof r.then === 'function') {\n          r.then(data => resolver(null, data)).catch(resolver);\n        } else {\n          resolver(null, r);\n        }\n      } catch (err) {\n        resolver(err);\n      }\n      return;\n    }\n    return fc(lng, ns, resolver);\n  }\n  prepareLoading(languages, namespaces) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let callback = arguments.length > 3 ? arguments[3] : undefined;\n    if (!this.backend) {\n      this.logger.warn('No backend was added via i18next.use. Will not load resources.');\n      return callback && callback();\n    }\n    if (typeof languages === 'string') languages = this.languageUtils.toResolveHierarchy(languages);\n    if (typeof namespaces === 'string') namespaces = [namespaces];\n    const toLoad = this.queueLoad(languages, namespaces, options, callback);\n    if (!toLoad.toLoad.length) {\n      if (!toLoad.pending.length) callback();\n      return null;\n    }\n    toLoad.toLoad.forEach(name => {\n      this.loadOne(name);\n    });\n  }\n  load(languages, namespaces, callback) {\n    this.prepareLoading(languages, namespaces, {}, callback);\n  }\n  reload(languages, namespaces, callback) {\n    this.prepareLoading(languages, namespaces, {\n      reload: true\n    }, callback);\n  }\n  loadOne(name) {\n    let prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n    const s = name.split('|');\n    const lng = s[0];\n    const ns = s[1];\n    this.read(lng, ns, 'read', undefined, undefined, (err, data) => {\n      if (err) this.logger.warn(`${prefix}loading namespace ${ns} for language ${lng} failed`, err);\n      if (!err && data) this.logger.log(`${prefix}loaded namespace ${ns} for language ${lng}`, data);\n      this.loaded(name, err, data);\n    });\n  }\n  saveMissing(languages, namespace, key, fallbackValue, isUpdate) {\n    let options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n    let clb = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : () => {};\n    if (this.services.utils && this.services.utils.hasLoadedNamespace && !this.services.utils.hasLoadedNamespace(namespace)) {\n      this.logger.warn(`did not save key \"${key}\" as the namespace \"${namespace}\" was not yet loaded`, 'This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!');\n      return;\n    }\n    if (key === undefined || key === null || key === '') return;\n    if (this.backend && this.backend.create) {\n      const opts = {\n        ...options,\n        isUpdate\n      };\n      const fc = this.backend.create.bind(this.backend);\n      if (fc.length < 6) {\n        try {\n          let r;\n          if (fc.length === 5) {\n            r = fc(languages, namespace, key, fallbackValue, opts);\n          } else {\n            r = fc(languages, namespace, key, fallbackValue);\n          }\n          if (r && typeof r.then === 'function') {\n            r.then(data => clb(null, data)).catch(clb);\n          } else {\n            clb(null, r);\n          }\n        } catch (err) {\n          clb(err);\n        }\n      } else {\n        fc(languages, namespace, key, fallbackValue, clb, opts);\n      }\n    }\n    if (!languages || !languages[0]) return;\n    this.store.addResource(languages[0], namespace, key, fallbackValue);\n  }\n}\n\nfunction get() {\n  return {\n    debug: false,\n    initImmediate: true,\n    ns: ['translation'],\n    defaultNS: ['translation'],\n    fallbackLng: ['dev'],\n    fallbackNS: false,\n    supportedLngs: false,\n    nonExplicitSupportedLngs: false,\n    load: 'all',\n    preload: false,\n    simplifyPluralSuffix: true,\n    keySeparator: '.',\n    nsSeparator: ':',\n    pluralSeparator: '_',\n    contextSeparator: '_',\n    partialBundledLanguages: false,\n    saveMissing: false,\n    updateMissing: false,\n    saveMissingTo: 'fallback',\n    saveMissingPlurals: true,\n    missingKeyHandler: false,\n    missingInterpolationHandler: false,\n    postProcess: false,\n    postProcessPassResolved: false,\n    returnNull: false,\n    returnEmptyString: true,\n    returnObjects: false,\n    joinArrays: false,\n    returnedObjectHandler: false,\n    parseMissingKeyHandler: false,\n    appendNamespaceToMissingKey: false,\n    appendNamespaceToCIMode: false,\n    overloadTranslationOptionHandler: function handle(args) {\n      let ret = {};\n      if (typeof args[1] === 'object') ret = args[1];\n      if (typeof args[1] === 'string') ret.defaultValue = args[1];\n      if (typeof args[2] === 'string') ret.tDescription = args[2];\n      if (typeof args[2] === 'object' || typeof args[3] === 'object') {\n        const options = args[3] || args[2];\n        Object.keys(options).forEach(key => {\n          ret[key] = options[key];\n        });\n      }\n      return ret;\n    },\n    interpolation: {\n      escapeValue: true,\n      format: value => value,\n      prefix: '{{',\n      suffix: '}}',\n      formatSeparator: ',',\n      unescapePrefix: '-',\n      nestingPrefix: '$t(',\n      nestingSuffix: ')',\n      nestingOptionsSeparator: ',',\n      maxReplaces: 1000,\n      skipOnVariables: true\n    }\n  };\n}\nfunction transformOptions(options) {\n  if (typeof options.ns === 'string') options.ns = [options.ns];\n  if (typeof options.fallbackLng === 'string') options.fallbackLng = [options.fallbackLng];\n  if (typeof options.fallbackNS === 'string') options.fallbackNS = [options.fallbackNS];\n  if (options.supportedLngs && options.supportedLngs.indexOf('cimode') < 0) {\n    options.supportedLngs = options.supportedLngs.concat(['cimode']);\n  }\n  return options;\n}\n\nfunction noop() {}\nfunction bindMemberFunctions(inst) {\n  const mems = Object.getOwnPropertyNames(Object.getPrototypeOf(inst));\n  mems.forEach(mem => {\n    if (typeof inst[mem] === 'function') {\n      inst[mem] = inst[mem].bind(inst);\n    }\n  });\n}\nclass I18n extends EventEmitter {\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let callback = arguments.length > 1 ? arguments[1] : undefined;\n    super();\n    this.options = transformOptions(options);\n    this.services = {};\n    this.logger = baseLogger;\n    this.modules = {\n      external: []\n    };\n    bindMemberFunctions(this);\n    if (callback && !this.isInitialized && !options.isClone) {\n      if (!this.options.initImmediate) {\n        this.init(options, callback);\n        return this;\n      }\n      setTimeout(() => {\n        this.init(options, callback);\n      }, 0);\n    }\n  }\n  init() {\n    var _this = this;\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let callback = arguments.length > 1 ? arguments[1] : undefined;\n    this.isInitializing = true;\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n    if (!options.defaultNS && options.defaultNS !== false && options.ns) {\n      if (typeof options.ns === 'string') {\n        options.defaultNS = options.ns;\n      } else if (options.ns.indexOf('translation') < 0) {\n        options.defaultNS = options.ns[0];\n      }\n    }\n    const defOpts = get();\n    this.options = {\n      ...defOpts,\n      ...this.options,\n      ...transformOptions(options)\n    };\n    if (this.options.compatibilityAPI !== 'v1') {\n      this.options.interpolation = {\n        ...defOpts.interpolation,\n        ...this.options.interpolation\n      };\n    }\n    if (options.keySeparator !== undefined) {\n      this.options.userDefinedKeySeparator = options.keySeparator;\n    }\n    if (options.nsSeparator !== undefined) {\n      this.options.userDefinedNsSeparator = options.nsSeparator;\n    }\n    function createClassOnDemand(ClassOrObject) {\n      if (!ClassOrObject) return null;\n      if (typeof ClassOrObject === 'function') return new ClassOrObject();\n      return ClassOrObject;\n    }\n    if (!this.options.isClone) {\n      if (this.modules.logger) {\n        baseLogger.init(createClassOnDemand(this.modules.logger), this.options);\n      } else {\n        baseLogger.init(null, this.options);\n      }\n      let formatter;\n      if (this.modules.formatter) {\n        formatter = this.modules.formatter;\n      } else if (typeof Intl !== 'undefined') {\n        formatter = Formatter;\n      }\n      const lu = new LanguageUtil(this.options);\n      this.store = new ResourceStore(this.options.resources, this.options);\n      const s = this.services;\n      s.logger = baseLogger;\n      s.resourceStore = this.store;\n      s.languageUtils = lu;\n      s.pluralResolver = new PluralResolver(lu, {\n        prepend: this.options.pluralSeparator,\n        compatibilityJSON: this.options.compatibilityJSON,\n        simplifyPluralSuffix: this.options.simplifyPluralSuffix\n      });\n      if (formatter && (!this.options.interpolation.format || this.options.interpolation.format === defOpts.interpolation.format)) {\n        s.formatter = createClassOnDemand(formatter);\n        s.formatter.init(s, this.options);\n        this.options.interpolation.format = s.formatter.format.bind(s.formatter);\n      }\n      s.interpolator = new Interpolator(this.options);\n      s.utils = {\n        hasLoadedNamespace: this.hasLoadedNamespace.bind(this)\n      };\n      s.backendConnector = new Connector(createClassOnDemand(this.modules.backend), s.resourceStore, s, this.options);\n      s.backendConnector.on('*', function (event) {\n        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n          args[_key - 1] = arguments[_key];\n        }\n        _this.emit(event, ...args);\n      });\n      if (this.modules.languageDetector) {\n        s.languageDetector = createClassOnDemand(this.modules.languageDetector);\n        if (s.languageDetector.init) s.languageDetector.init(s, this.options.detection, this.options);\n      }\n      if (this.modules.i18nFormat) {\n        s.i18nFormat = createClassOnDemand(this.modules.i18nFormat);\n        if (s.i18nFormat.init) s.i18nFormat.init(this);\n      }\n      this.translator = new Translator(this.services, this.options);\n      this.translator.on('*', function (event) {\n        for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n          args[_key2 - 1] = arguments[_key2];\n        }\n        _this.emit(event, ...args);\n      });\n      this.modules.external.forEach(m => {\n        if (m.init) m.init(this);\n      });\n    }\n    this.format = this.options.interpolation.format;\n    if (!callback) callback = noop;\n    if (this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {\n      const codes = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);\n      if (codes.length > 0 && codes[0] !== 'dev') this.options.lng = codes[0];\n    }\n    if (!this.services.languageDetector && !this.options.lng) {\n      this.logger.warn('init: no languageDetector is used and no lng is defined');\n    }\n    const storeApi = ['getResource', 'hasResourceBundle', 'getResourceBundle', 'getDataByLanguage'];\n    storeApi.forEach(fcName => {\n      this[fcName] = function () {\n        return _this.store[fcName](...arguments);\n      };\n    });\n    const storeApiChained = ['addResource', 'addResources', 'addResourceBundle', 'removeResourceBundle'];\n    storeApiChained.forEach(fcName => {\n      this[fcName] = function () {\n        _this.store[fcName](...arguments);\n        return _this;\n      };\n    });\n    const deferred = defer();\n    const load = () => {\n      const finish = (err, t) => {\n        this.isInitializing = false;\n        if (this.isInitialized && !this.initializedStoreOnce) this.logger.warn('init: i18next is already initialized. You should call init just once!');\n        this.isInitialized = true;\n        if (!this.options.isClone) this.logger.log('initialized', this.options);\n        this.emit('initialized', this.options);\n        deferred.resolve(t);\n        callback(err, t);\n      };\n      if (this.languages && this.options.compatibilityAPI !== 'v1' && !this.isInitialized) return finish(null, this.t.bind(this));\n      this.changeLanguage(this.options.lng, finish);\n    };\n    if (this.options.resources || !this.options.initImmediate) {\n      load();\n    } else {\n      setTimeout(load, 0);\n    }\n    return deferred;\n  }\n  loadResources(language) {\n    let callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;\n    let usedCallback = callback;\n    const usedLng = typeof language === 'string' ? language : this.language;\n    if (typeof language === 'function') usedCallback = language;\n    if (!this.options.resources || this.options.partialBundledLanguages) {\n      if (usedLng && usedLng.toLowerCase() === 'cimode' && (!this.options.preload || this.options.preload.length === 0)) return usedCallback();\n      const toLoad = [];\n      const append = lng => {\n        if (!lng) return;\n        if (lng === 'cimode') return;\n        const lngs = this.services.languageUtils.toResolveHierarchy(lng);\n        lngs.forEach(l => {\n          if (l === 'cimode') return;\n          if (toLoad.indexOf(l) < 0) toLoad.push(l);\n        });\n      };\n      if (!usedLng) {\n        const fallbacks = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);\n        fallbacks.forEach(l => append(l));\n      } else {\n        append(usedLng);\n      }\n      if (this.options.preload) {\n        this.options.preload.forEach(l => append(l));\n      }\n      this.services.backendConnector.load(toLoad, this.options.ns, e => {\n        if (!e && !this.resolvedLanguage && this.language) this.setResolvedLanguage(this.language);\n        usedCallback(e);\n      });\n    } else {\n      usedCallback(null);\n    }\n  }\n  reloadResources(lngs, ns, callback) {\n    const deferred = defer();\n    if (!lngs) lngs = this.languages;\n    if (!ns) ns = this.options.ns;\n    if (!callback) callback = noop;\n    this.services.backendConnector.reload(lngs, ns, err => {\n      deferred.resolve();\n      callback(err);\n    });\n    return deferred;\n  }\n  use(module) {\n    if (!module) throw new Error('You are passing an undefined module! Please check the object you are passing to i18next.use()');\n    if (!module.type) throw new Error('You are passing a wrong module! Please check the object you are passing to i18next.use()');\n    if (module.type === 'backend') {\n      this.modules.backend = module;\n    }\n    if (module.type === 'logger' || module.log && module.warn && module.error) {\n      this.modules.logger = module;\n    }\n    if (module.type === 'languageDetector') {\n      this.modules.languageDetector = module;\n    }\n    if (module.type === 'i18nFormat') {\n      this.modules.i18nFormat = module;\n    }\n    if (module.type === 'postProcessor') {\n      postProcessor.addPostProcessor(module);\n    }\n    if (module.type === 'formatter') {\n      this.modules.formatter = module;\n    }\n    if (module.type === '3rdParty') {\n      this.modules.external.push(module);\n    }\n    return this;\n  }\n  setResolvedLanguage(l) {\n    if (!l || !this.languages) return;\n    if (['cimode', 'dev'].indexOf(l) > -1) return;\n    for (let li = 0; li < this.languages.length; li++) {\n      const lngInLngs = this.languages[li];\n      if (['cimode', 'dev'].indexOf(lngInLngs) > -1) continue;\n      if (this.store.hasLanguageSomeTranslations(lngInLngs)) {\n        this.resolvedLanguage = lngInLngs;\n        break;\n      }\n    }\n  }\n  changeLanguage(lng, callback) {\n    var _this2 = this;\n    this.isLanguageChangingTo = lng;\n    const deferred = defer();\n    this.emit('languageChanging', lng);\n    const setLngProps = l => {\n      this.language = l;\n      this.languages = this.services.languageUtils.toResolveHierarchy(l);\n      this.resolvedLanguage = undefined;\n      this.setResolvedLanguage(l);\n    };\n    const done = (err, l) => {\n      if (l) {\n        setLngProps(l);\n        this.translator.changeLanguage(l);\n        this.isLanguageChangingTo = undefined;\n        this.emit('languageChanged', l);\n        this.logger.log('languageChanged', l);\n      } else {\n        this.isLanguageChangingTo = undefined;\n      }\n      deferred.resolve(function () {\n        return _this2.t(...arguments);\n      });\n      if (callback) callback(err, function () {\n        return _this2.t(...arguments);\n      });\n    };\n    const setLng = lngs => {\n      if (!lng && !lngs && this.services.languageDetector) lngs = [];\n      const l = typeof lngs === 'string' ? lngs : this.services.languageUtils.getBestMatchFromCodes(lngs);\n      if (l) {\n        if (!this.language) {\n          setLngProps(l);\n        }\n        if (!this.translator.language) this.translator.changeLanguage(l);\n        if (this.services.languageDetector && this.services.languageDetector.cacheUserLanguage) this.services.languageDetector.cacheUserLanguage(l);\n      }\n      this.loadResources(l, err => {\n        done(err, l);\n      });\n    };\n    if (!lng && this.services.languageDetector && !this.services.languageDetector.async) {\n      setLng(this.services.languageDetector.detect());\n    } else if (!lng && this.services.languageDetector && this.services.languageDetector.async) {\n      if (this.services.languageDetector.detect.length === 0) {\n        this.services.languageDetector.detect().then(setLng);\n      } else {\n        this.services.languageDetector.detect(setLng);\n      }\n    } else {\n      setLng(lng);\n    }\n    return deferred;\n  }\n  getFixedT(lng, ns, keyPrefix) {\n    var _this3 = this;\n    const fixedT = function (key, opts) {\n      let options;\n      if (typeof opts !== 'object') {\n        for (var _len3 = arguments.length, rest = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {\n          rest[_key3 - 2] = arguments[_key3];\n        }\n        options = _this3.options.overloadTranslationOptionHandler([key, opts].concat(rest));\n      } else {\n        options = {\n          ...opts\n        };\n      }\n      options.lng = options.lng || fixedT.lng;\n      options.lngs = options.lngs || fixedT.lngs;\n      options.ns = options.ns || fixedT.ns;\n      options.keyPrefix = options.keyPrefix || keyPrefix || fixedT.keyPrefix;\n      const keySeparator = _this3.options.keySeparator || '.';\n      let resultKey;\n      if (options.keyPrefix && Array.isArray(key)) {\n        resultKey = key.map(k => `${options.keyPrefix}${keySeparator}${k}`);\n      } else {\n        resultKey = options.keyPrefix ? `${options.keyPrefix}${keySeparator}${key}` : key;\n      }\n      return _this3.t(resultKey, options);\n    };\n    if (typeof lng === 'string') {\n      fixedT.lng = lng;\n    } else {\n      fixedT.lngs = lng;\n    }\n    fixedT.ns = ns;\n    fixedT.keyPrefix = keyPrefix;\n    return fixedT;\n  }\n  t() {\n    return this.translator && this.translator.translate(...arguments);\n  }\n  exists() {\n    return this.translator && this.translator.exists(...arguments);\n  }\n  setDefaultNamespace(ns) {\n    this.options.defaultNS = ns;\n  }\n  hasLoadedNamespace(ns) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (!this.isInitialized) {\n      this.logger.warn('hasLoadedNamespace: i18next was not initialized', this.languages);\n      return false;\n    }\n    if (!this.languages || !this.languages.length) {\n      this.logger.warn('hasLoadedNamespace: i18n.languages were undefined or empty', this.languages);\n      return false;\n    }\n    const lng = options.lng || this.resolvedLanguage || this.languages[0];\n    const fallbackLng = this.options ? this.options.fallbackLng : false;\n    const lastLng = this.languages[this.languages.length - 1];\n    if (lng.toLowerCase() === 'cimode') return true;\n    const loadNotPending = (l, n) => {\n      const loadState = this.services.backendConnector.state[`${l}|${n}`];\n      return loadState === -1 || loadState === 2;\n    };\n    if (options.precheck) {\n      const preResult = options.precheck(this, loadNotPending);\n      if (preResult !== undefined) return preResult;\n    }\n    if (this.hasResourceBundle(lng, ns)) return true;\n    if (!this.services.backendConnector.backend || this.options.resources && !this.options.partialBundledLanguages) return true;\n    if (loadNotPending(lng, ns) && (!fallbackLng || loadNotPending(lastLng, ns))) return true;\n    return false;\n  }\n  loadNamespaces(ns, callback) {\n    const deferred = defer();\n    if (!this.options.ns) {\n      if (callback) callback();\n      return Promise.resolve();\n    }\n    if (typeof ns === 'string') ns = [ns];\n    ns.forEach(n => {\n      if (this.options.ns.indexOf(n) < 0) this.options.ns.push(n);\n    });\n    this.loadResources(err => {\n      deferred.resolve();\n      if (callback) callback(err);\n    });\n    return deferred;\n  }\n  loadLanguages(lngs, callback) {\n    const deferred = defer();\n    if (typeof lngs === 'string') lngs = [lngs];\n    const preloaded = this.options.preload || [];\n    const newLngs = lngs.filter(lng => preloaded.indexOf(lng) < 0);\n    if (!newLngs.length) {\n      if (callback) callback();\n      return Promise.resolve();\n    }\n    this.options.preload = preloaded.concat(newLngs);\n    this.loadResources(err => {\n      deferred.resolve();\n      if (callback) callback(err);\n    });\n    return deferred;\n  }\n  dir(lng) {\n    if (!lng) lng = this.resolvedLanguage || (this.languages && this.languages.length > 0 ? this.languages[0] : this.language);\n    if (!lng) return 'rtl';\n    const rtlLngs = ['ar', 'shu', 'sqr', 'ssh', 'xaa', 'yhd', 'yud', 'aao', 'abh', 'abv', 'acm', 'acq', 'acw', 'acx', 'acy', 'adf', 'ads', 'aeb', 'aec', 'afb', 'ajp', 'apc', 'apd', 'arb', 'arq', 'ars', 'ary', 'arz', 'auz', 'avl', 'ayh', 'ayl', 'ayn', 'ayp', 'bbz', 'pga', 'he', 'iw', 'ps', 'pbt', 'pbu', 'pst', 'prp', 'prd', 'ug', 'ur', 'ydd', 'yds', 'yih', 'ji', 'yi', 'hbo', 'men', 'xmn', 'fa', 'jpr', 'peo', 'pes', 'prs', 'dv', 'sam', 'ckb'];\n    const languageUtils = this.services && this.services.languageUtils || new LanguageUtil(get());\n    return rtlLngs.indexOf(languageUtils.getLanguagePartFromCode(lng)) > -1 || lng.toLowerCase().indexOf('-arab') > 1 ? 'rtl' : 'ltr';\n  }\n  static createInstance() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let callback = arguments.length > 1 ? arguments[1] : undefined;\n    return new I18n(options, callback);\n  }\n  cloneInstance() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;\n    const forkResourceStore = options.forkResourceStore;\n    if (forkResourceStore) delete options.forkResourceStore;\n    const mergedOptions = {\n      ...this.options,\n      ...options,\n      ...{\n        isClone: true\n      }\n    };\n    const clone = new I18n(mergedOptions);\n    if (options.debug !== undefined || options.prefix !== undefined) {\n      clone.logger = clone.logger.clone(options);\n    }\n    const membersToCopy = ['store', 'services', 'language'];\n    membersToCopy.forEach(m => {\n      clone[m] = this[m];\n    });\n    clone.services = {\n      ...this.services\n    };\n    clone.services.utils = {\n      hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)\n    };\n    if (forkResourceStore) {\n      clone.store = new ResourceStore(this.store.data, mergedOptions);\n      clone.services.resourceStore = clone.store;\n    }\n    clone.translator = new Translator(clone.services, mergedOptions);\n    clone.translator.on('*', function (event) {\n      for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n        args[_key4 - 1] = arguments[_key4];\n      }\n      clone.emit(event, ...args);\n    });\n    clone.init(mergedOptions, callback);\n    clone.translator.options = mergedOptions;\n    clone.translator.backendConnector.services.utils = {\n      hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)\n    };\n    return clone;\n  }\n  toJSON() {\n    return {\n      options: this.options,\n      store: this.store,\n      language: this.language,\n      languages: this.languages,\n      resolvedLanguage: this.resolvedLanguage\n    };\n  }\n}\nconst instance = I18n.createInstance();\ninstance.createInstance = I18n.createInstance;\n\nconst createInstance = instance.createInstance;\nconst dir = instance.dir;\nconst init = instance.init;\nconst loadResources = instance.loadResources;\nconst reloadResources = instance.reloadResources;\nconst use = instance.use;\nconst changeLanguage = instance.changeLanguage;\nconst getFixedT = instance.getFixedT;\nconst t = instance.t;\nconst exists = instance.exists;\nconst setDefaultNamespace = instance.setDefaultNamespace;\nconst hasLoadedNamespace = instance.hasLoadedNamespace;\nconst loadNamespaces = instance.loadNamespaces;\nconst loadLanguages = instance.loadLanguages;\n\n\n\n\n//# sourceURL=webpack://gut.tech/./node_modules/i18next/dist/esm/i18next.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./html/js/index.js");
/******/ 	
/******/ })()
;